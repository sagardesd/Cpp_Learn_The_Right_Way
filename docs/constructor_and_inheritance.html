<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Construtors and Destructors in Inheritance - C++ Learn The Right Way</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>â†</kbd> or <kbd>â†’</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">C++ Learn The Right Way</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/sagardesd/Cpp_Learn_The_Right_Way" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="constructor-execution-in-inheritance---c"><a class="header" href="#constructor-execution-in-inheritance---c">Constructor Execution in Inheritance - C++</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ol>
<li><a href="#understanding-constructor-execution-order">Understanding Constructor Execution Order</a></li>
<li><a href="#default-constructor-behavior">Default Constructor Behavior</a></li>
<li><a href="#execution-sequence-analysis">Execution Sequence Analysis</a></li>
<li><a href="#calling-parameterized-base-constructors">Calling Parameterized Base Constructors</a></li>
<li><a href="#complete-example-with-explanation">Complete Example with Explanation</a></li>
<li><a href="#inheriting-constructors-cpp11">Inheriting constructors - C++11</a></li>
<li><a href="#limitations-of-inherited-constructors">Limitation of inherited construtors - C++11</a></li>
<li><a href="#destructors-order-inheritance">Understanding Destructor Execution Order</a></li>
</ol>
<hr />
<p><a id="understanding-constructor-execution-order"></a></p>
<h2 id="1-understanding-constructor-execution-order"><a class="header" href="#1-understanding-constructor-execution-order">1. Understanding Constructor Execution Order</a></h2>
<p>When creating an object of a derived class, constructors are called in a specific order:</p>
<h3 id="order-of-construction"><a class="header" href="#order-of-construction">Order of Construction:</a></h3>
<ol>
<li><strong>Base class constructor</strong> (top of hierarchy) - <strong>First</strong></li>
<li><strong>Intermediate class constructors</strong> (if any)</li>
<li><strong>Derived class constructor</strong> (bottom of hierarchy) - <strong>Last</strong></li>
</ol>
<h3 id="order-of-destruction-reverse-order"><a class="header" href="#order-of-destruction-reverse-order">Order of Destruction: (Reverse order)</a></h3>
<ol>
<li><strong>Derived class destructor</strong> - <strong>First</strong></li>
<li><strong>Intermediate class destructors</strong></li>
<li><strong>Base class destructor</strong> - <strong>Last</strong></li>
</ol>
<h3 id="why-this-order"><a class="header" href="#why-this-order">Why This Order?</a></h3>
<p>The derived class depends on the base class being fully constructed first. You can't build a house's roof before building its foundation!</p>
<pre><code>Construction:  Base â†’ Intermediate â†’ Derived (Bottom-up)
Destruction:   Derived â†’ Intermediate â†’ Base (Top-down)
</code></pre>
<p><a href="#table-of-contents">â†‘ Back to Table of Contents</a></p>
<hr />
<p><a id="default-constructor-behavior"></a></p>
<h2 id="2-default-constructor-behavior"><a class="header" href="#2-default-constructor-behavior">2. Default Constructor Behavior</a></h2>
<h3 id="original-example"><a class="header" href="#original-example">Original Example</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;

class A {
public:
    A() : a(1) {
        std::cout &lt;&lt; "A(): a = " &lt;&lt; a &lt;&lt; std::endl;
    }
    A(int a) : a(a) {
        std::cout &lt;&lt; "A(int): a = " &lt;&lt; a &lt;&lt; std::endl;
    }
private:
    int a;
};

class B : public A {
public:
    B() : b(2) {
        std::cout &lt;&lt; "B(): b = " &lt;&lt; b &lt;&lt; std::endl;
    }
    B(int b) : b(b) {
        std::cout &lt;&lt; "B(int): b = " &lt;&lt; b &lt;&lt; std::endl;
    }
private:
    int b;
};

class C : public B {
public:
    C() : c(3) {
        std::cout &lt;&lt; "C(): c = " &lt;&lt; c &lt;&lt; std::endl;
    }
    C(int c) : c(c) {
        std::cout &lt;&lt; "C(int): c = " &lt;&lt; c &lt;&lt; std::endl;
    }
private:
    int c;
};

int main(int argc, char* argv[]) {
    std::cout &lt;&lt; "Without parameter:" &lt;&lt; std::endl;
    C c_obj{};
    std::cout &lt;&lt; "\nWith parameter:" &lt;&lt; std::endl;
    C c_obj_param{30};
    return 0;
}
</code></pre>
<h3 id="output"><a class="header" href="#output">Output</a></h3>
<pre><code>Without parameter:
A(): a = 1
B(): b = 2
C(): c = 3

With parameter:
A(): a = 1
B(): b = 2
C(int): c = 30
</code></pre>
<h3 id="key-observation"><a class="header" href="#key-observation">Key Observation</a></h3>
<p>Notice that even when we call <code>C(int)</code> with a parameter, the base classes <code>A</code> and <code>B</code> still use their <strong>default constructors</strong>!</p>
<p><a href="#table-of-contents">â†‘ Back to Table of Contents</a></p>
<hr />
<p><a id="execution-sequence-analysis"></a></p>
<h2 id="3-execution-sequence-analysis"><a class="header" href="#3-execution-sequence-analysis">3. Execution Sequence Analysis</a></h2>
<h3 id="case-1-c-c_obj-default-constructor"><a class="header" href="#case-1-c-c_obj-default-constructor">Case 1: <code>C c_obj{};</code> (Default Constructor)</a></h3>
<h4 id="what-the-compiler-sees"><a class="header" href="#what-the-compiler-sees">What the Compiler Sees:</a></h4>
<pre><code class="language-cpp">C() : c(3) {
    std::cout &lt;&lt; "C(): c = " &lt;&lt; c &lt;&lt; std::endl;
}
</code></pre>
<h4 id="what-the-compiler-does-implicit"><a class="header" href="#what-the-compiler-does-implicit">What the Compiler Does (Implicit):</a></h4>
<pre><code class="language-cpp">C() : B(),     // â† Implicitly calls B's default constructor
      c(3) {
    std::cout &lt;&lt; "C(): c = " &lt;&lt; c &lt;&lt; std::endl;
}
</code></pre>
<p>And <code>B()</code> does the same:</p>
<pre><code class="language-cpp">B() : A(),     // â† Implicitly calls A's default constructor
      b(2) {
    std::cout &lt;&lt; "B(): b = " &lt;&lt; b &lt;&lt; std::endl;
}
</code></pre>
<h4 id="execution-flow"><a class="header" href="#execution-flow">Execution Flow:</a></h4>
<pre><code>Step 1: C() constructor called
   â”‚
   â”œâ”€â”€&gt; Step 2: Compiler sees no explicit base constructor call
   â”‚            Automatically calls B() (default)
   â”‚              â”‚
   â”‚              â”œâ”€â”€&gt; Step 3: B() constructor starts
   â”‚              â”‚           Compiler sees no explicit base constructor call
   â”‚              â”‚           Automatically calls A() (default)
   â”‚              â”‚              â”‚
   â”‚              â”‚              â”œâ”€â”€&gt; Step 4: A() constructor starts
   â”‚              â”‚              â”‚           Initializes: a = 1
   â”‚              â”‚              â”‚           Prints: "A(): a = 1"
   â”‚              â”‚              â””â”€â”€&gt; A() constructor completes
   â”‚              â”‚
   â”‚              â”œâ”€â”€&gt; Step 5: B() constructor continues
   â”‚              â”‚           Initializes: b = 2
   â”‚              â”‚           Prints: "B(): b = 2"
   â”‚              â””â”€â”€&gt; B() constructor completes
   â”‚
   â”œâ”€â”€&gt; Step 6: C() constructor continues
   â”‚           Initializes: c = 3
   â”‚           Prints: "C(): c = 3"
   â””â”€â”€&gt; C() constructor completes
</code></pre>
<p><strong>Visual Timeline:</strong></p>
<pre><code>Time â†’
[A() starts] â†’ [a=1] â†’ [Print "A()"] â†’ [A() done]
                                          â†“
                       [B() starts] â†’ [b=2] â†’ [Print "B()"] â†’ [B() done]
                                                                 â†“
                                              [C() starts] â†’ [c=3] â†’ [Print "C()"] â†’ [C() done]
</code></pre>
<h3 id="case-2-c-c_obj_param30-parameterized-constructor"><a class="header" href="#case-2-c-c_obj_param30-parameterized-constructor">Case 2: <code>C c_obj_param{30};</code> (Parameterized Constructor)</a></h3>
<h4 id="what-the-compiler-sees-1"><a class="header" href="#what-the-compiler-sees-1">What the Compiler Sees:</a></h4>
<pre><code class="language-cpp">C(int c) : c(c) {
    std::cout &lt;&lt; "C(int): c = " &lt;&lt; c &lt;&lt; std::endl;
}
</code></pre>
<h4 id="what-the-compiler-does-implicit-1"><a class="header" href="#what-the-compiler-does-implicit-1">What the Compiler Does (Implicit):</a></h4>
<pre><code class="language-cpp">C(int c) : B(),    // â† Still implicitly calls B's DEFAULT constructor!
           c(c) {
    std::cout &lt;&lt; "C(int): c = " &lt;&lt; c &lt;&lt; std::endl;
}
</code></pre>
<h4 id="execution-flow-1"><a class="header" href="#execution-flow-1">Execution Flow:</a></h4>
<pre><code>Step 1: C(int) constructor called with c = 30
   â”‚
   â”œâ”€â”€&gt; Step 2: Compiler sees no explicit base constructor call
   â”‚            Automatically calls B() (default, not B(int)!)
   â”‚              â”‚
   â”‚              â”œâ”€â”€&gt; Step 3: B() constructor starts
   â”‚              â”‚           Automatically calls A() (default)
   â”‚              â”‚              â”‚
   â”‚              â”‚              â”œâ”€â”€&gt; Step 4: A() constructor
   â”‚              â”‚              â”‚           Initializes: a = 1
   â”‚              â”‚              â”‚           Prints: "A(): a = 1"
   â”‚              â”‚              â””â”€â”€&gt; A() completes
   â”‚              â”‚
   â”‚              â”œâ”€â”€&gt; Step 5: B() constructor continues
   â”‚              â”‚           Initializes: b = 2
   â”‚              â”‚           Prints: "B(): b = 2"
   â”‚              â””â”€â”€&gt; B() completes
   â”‚
   â”œâ”€â”€&gt; Step 6: C(int) constructor continues
   â”‚           Initializes: c = 30 (uses the parameter!)
   â”‚           Prints: "C(int): c = 30"
   â””â”€â”€&gt; C(int) completes
</code></pre>
<h3 id="important-rule"><a class="header" href="#important-rule">Important Rule</a></h3>
<blockquote>
<p><strong>If a derived class constructor doesn't EXPLICITLY call a base class constructor in its initializer list, the compiler AUTOMATICALLY calls the base class's DEFAULT constructor.</strong></p>
</blockquote>
<p>This means:</p>
<ul>
<li>You wrote: <code>C(int c) : c(c) { }</code></li>
<li>Compiler executes: <code>C(int c) : B(), c(c) { }</code></li>
<li><code>B()</code> then executes: <code>B() : A(), b(2) { }</code></li>
</ul>
<p><a href="#table-of-contents">â†‘ Back to Table of Contents</a></p>
<hr />
<p><a id="calling-parameterized-base-constructors"></a></p>
<h2 id="4-calling-parameterized-base-constructors"><a class="header" href="#4-calling-parameterized-base-constructors">4. Calling Parameterized Base Constructors</a></h2>
<p>To use parameterized constructors of base classes, you must <strong>explicitly call them</strong> in the initializer list.</p>
<h3 id="modified-code"><a class="header" href="#modified-code">Modified Code</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;

class A {
public:
    A() : a(1) {
        std::cout &lt;&lt; "A(): a = " &lt;&lt; a &lt;&lt; std::endl;
    }
    A(int a) : a(a) {
        std::cout &lt;&lt; "A(int): a = " &lt;&lt; a &lt;&lt; std::endl;
    }
private:
    int a;
};

class B : public A {
public:
    B() : A(), b(2) {  // Explicitly call A() (though it's implicit)
        std::cout &lt;&lt; "B(): b = " &lt;&lt; b &lt;&lt; std::endl;
    }
    B(int b) : A(), b(b) {  // Explicitly call A()
        std::cout &lt;&lt; "B(int): b = " &lt;&lt; b &lt;&lt; std::endl;
    }
    // New: Constructor that takes parameters for both B and A
    B(int a_val, int b_val) : A(a_val), b(b_val) {
        std::cout &lt;&lt; "B(int, int): b = " &lt;&lt; b &lt;&lt; std::endl;
    }
private:
    int b;
};

class C : public B {
public:
    C() : B(), c(3) {  // Explicitly call B()
        std::cout &lt;&lt; "C(): c = " &lt;&lt; c &lt;&lt; std::endl;
    }
    C(int c) : B(), c(c) {  // Explicitly call B()
        std::cout &lt;&lt; "C(int): c = " &lt;&lt; c &lt;&lt; std::endl;
    }
    // New: Constructor that takes parameters for C and B
    C(int b_val, int c_val) : B(b_val), c(c_val) {
        std::cout &lt;&lt; "C(int, int): c = " &lt;&lt; c &lt;&lt; std::endl;
    }
    // New: Constructor that takes parameters for all classes
    C(int a_val, int b_val, int c_val) : B(a_val, b_val), c(c_val) {
        std::cout &lt;&lt; "C(int, int, int): c = " &lt;&lt; c &lt;&lt; std::endl;
    }
private:
    int c;
};

int main(int argc, char* argv[]) {
    std::cout &lt;&lt; "=== Case 1: Default constructors ===" &lt;&lt; std::endl;
    C obj1{};
    
    std::cout &lt;&lt; "\n=== Case 2: Only C parameter ===" &lt;&lt; std::endl;
    C obj2{30};
    
    std::cout &lt;&lt; "\n=== Case 3: B and C parameters ===" &lt;&lt; std::endl;
    C obj3{20, 30};
    
    std::cout &lt;&lt; "\n=== Case 4: A, B, and C parameters ===" &lt;&lt; std::endl;
    C obj4{10, 20, 30};
    
    return 0;
}
</code></pre>
<h3 id="output-1"><a class="header" href="#output-1">Output</a></h3>
<pre><code>=== Case 1: Default constructors ===
A(): a = 1
B(): b = 2
C(): c = 3

=== Case 2: Only C parameter ===
A(): a = 1
B(): b = 2
C(int): c = 30

=== Case 3: B and C parameters ===
A(): a = 1
B(int): b = 20
C(int, int): c = 30

=== Case 4: A, B, and C parameters ===
A(int): a = 10
B(int, int): b = 20
C(int, int, int): c = 30
</code></pre>
<p><a href="#table-of-contents">â†‘ Back to Table of Contents</a></p>
<hr />
<p><a id="complete-example-with-explanation"></a></p>
<h2 id="5-complete-example-with-explanation"><a class="header" href="#5-complete-example-with-explanation">5. Complete Example with Explanation</a></h2>
<h3 id="detailed-analysis-of-each-case"><a class="header" href="#detailed-analysis-of-each-case">Detailed Analysis of Each Case</a></h3>
<h4 id="case-1-c-obj1-all-default-constructors"><a class="header" href="#case-1-c-obj1-all-default-constructors">Case 1: <code>C obj1{};</code> (All Default Constructors)</a></h4>
<pre><code class="language-cpp">C() : B(), c(3) {
    std::cout &lt;&lt; "C(): c = " &lt;&lt; c &lt;&lt; std::endl;
}
</code></pre>
<p><strong>Execution:</strong></p>
<pre><code>A() called â†’ a = 1
B() called â†’ b = 2
C() called â†’ c = 3
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li><code>C()</code> calls <code>B()</code> (explicit in modified code, implicit in original)</li>
<li><code>B()</code> calls <code>A()</code> (explicit in modified code, implicit in original)</li>
<li>Each constructor uses default values</li>
</ul>
<hr />
<h4 id="case-2-c-obj230-only-c-gets-parameter"><a class="header" href="#case-2-c-obj230-only-c-gets-parameter">Case 2: <code>C obj2{30};</code> (Only C Gets Parameter)</a></h4>
<pre><code class="language-cpp">C(int c) : B(), c(c) {
    std::cout &lt;&lt; "C(int): c = " &lt;&lt; c &lt;&lt; std::endl;
}
</code></pre>
<p><strong>Execution:</strong></p>
<pre><code>A() called â†’ a = 1
B() called â†’ b = 2
C(int) called â†’ c = 30
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li><code>C(int)</code> explicitly calls <code>B()</code> (default constructor)</li>
<li><code>B()</code> implicitly calls <code>A()</code> (default constructor)</li>
<li>Only <code>c</code> gets the parameter value</li>
<li><code>a</code> and <code>b</code> still use defaults</li>
</ul>
<p><strong>Key Point:</strong> Passing a parameter to C doesn't automatically pass it to B or A!</p>
<hr />
<h4 id="case-3-c-obj320-30-b-and-c-get-parameters"><a class="header" href="#case-3-c-obj320-30-b-and-c-get-parameters">Case 3: <code>C obj3{20, 30};</code> (B and C Get Parameters)</a></h4>
<pre><code class="language-cpp">C(int b_val, int c_val) : B(b_val), c(c_val) {
    std::cout &lt;&lt; "C(int, int): c = " &lt;&lt; c &lt;&lt; std::endl;
}
</code></pre>
<p>Which calls:</p>
<pre><code class="language-cpp">B(int b) : A(), b(b) {
    std::cout &lt;&lt; "B(int): b = " &lt;&lt; b &lt;&lt; std::endl;
}
</code></pre>
<p><strong>Execution:</strong></p>
<pre><code>A() called â†’ a = 1
B(int) called â†’ b = 20
C(int, int) called â†’ c = 30
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li><code>C(int, int)</code> explicitly calls <code>B(int)</code> with <code>b_val = 20</code></li>
<li><code>B(int)</code> implicitly calls <code>A()</code> (default constructor)</li>
<li><code>a</code> still uses default, but <code>b</code> and <code>c</code> get parameters</li>
</ul>
<hr />
<h4 id="case-4-c-obj410-20-30-all-get-parameters"><a class="header" href="#case-4-c-obj410-20-30-all-get-parameters">Case 4: <code>C obj4{10, 20, 30};</code> (All Get Parameters)</a></h4>
<pre><code class="language-cpp">C(int a_val, int b_val, int c_val) : B(a_val, b_val), c(c_val) {
    std::cout &lt;&lt; "C(int, int, int): c = " &lt;&lt; c &lt;&lt; std::endl;
}
</code></pre>
<p>Which calls:</p>
<pre><code class="language-cpp">B(int a_val, int b_val) : A(a_val), b(b_val) {
    std::cout &lt;&lt; "B(int, int): b = " &lt;&lt; b &lt;&lt; std::endl;
}
</code></pre>
<p>Which calls:</p>
<pre><code class="language-cpp">A(int a) : a(a) {
    std::cout &lt;&lt; "A(int): a = " &lt;&lt; a &lt;&lt; std::endl;
}
</code></pre>
<p><strong>Execution:</strong></p>
<pre><code>A(int) called â†’ a = 10
B(int, int) called â†’ b = 20
C(int, int, int) called â†’ c = 30
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li><code>C(int, int, int)</code> explicitly calls <code>B(int, int)</code> with <code>a_val = 10, b_val = 20</code></li>
<li><code>B(int, int)</code> explicitly calls <code>A(int)</code> with <code>a_val = 10</code></li>
<li>All classes get their respective parameter values</li>
</ul>
<p><strong>This is the proper way to initialize the entire hierarchy with custom values!</strong></p>
<hr />
<h3 id="visual-representation-of-constructor-calls"><a class="header" href="#visual-representation-of-constructor-calls">Visual Representation of Constructor Calls</a></h3>
<pre><code>Case 1: C obj1{}
   C() 
    â””â”€&gt; B()
         â””â”€&gt; A()
              â””â”€&gt; a=1
         â””â”€&gt; b=2
    â””â”€&gt; c=3

Case 2: C obj2{30}
   C(int)  [param: 30]
    â””â”€&gt; B()
         â””â”€&gt; A()
              â””â”€&gt; a=1
         â””â”€&gt; b=2
    â””â”€&gt; c=30  â† Uses parameter

Case 3: C obj3{20, 30}
   C(int, int)  [params: 20, 30]
    â””â”€&gt; B(int)  [param: 20]
         â””â”€&gt; A()
              â””â”€&gt; a=1
         â””â”€&gt; b=20  â† Uses parameter
    â””â”€&gt; c=30  â† Uses parameter

Case 4: C obj4{10, 20, 30}
   C(int, int, int)  [params: 10, 20, 30]
    â””â”€&gt; B(int, int)  [params: 10, 20]
         â””â”€&gt; A(int)  [param: 10]
              â””â”€&gt; a=10  â† Uses parameter
         â””â”€&gt; b=20  â† Uses parameter
    â””â”€&gt; c=30  â† Uses parameter
</code></pre>
<hr />
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<h3 id="1-automatic-default-constructor-call"><a class="header" href="#1-automatic-default-constructor-call">1. Automatic Default Constructor Call</a></h3>
<ul>
<li>If you don't explicitly call a base class constructor, the compiler calls the <strong>default constructor</strong> automatically</li>
<li>This happens even if you call a parameterized constructor of the derived class</li>
</ul>
<h3 id="2-explicit-base-constructor-call"><a class="header" href="#2-explicit-base-constructor-call">2. Explicit Base Constructor Call</a></h3>
<ul>
<li>To use a parameterized base constructor, you MUST explicitly call it in the initializer list:
<pre><code class="language-cpp">DerivedClass(params) : BaseClass(params), members(values) {
    // constructor body
}
</code></pre>
</li>
</ul>
<h3 id="3-constructor-execution-order"><a class="header" href="#3-constructor-execution-order">3. Constructor Execution Order</a></h3>
<ul>
<li><strong>Always</strong> executes from base to derived (top-down in hierarchy)</li>
<li>Base class is fully constructed before derived class constructor body runs</li>
</ul>
<h3 id="4-passing-parameters-up-the-hierarchy"><a class="header" href="#4-passing-parameters-up-the-hierarchy">4. Passing Parameters Up the Hierarchy</a></h3>
<ul>
<li>Parameters don't automatically propagate to base classes</li>
<li>You must explicitly pass them through constructor calls:
<pre><code class="language-cpp">C(int a, int b, int c) : B(a, b), c(c) { }
</code></pre>
</li>
</ul>
<h3 id="5-initializer-list-order"><a class="header" href="#5-initializer-list-order">5. Initializer List Order</a></h3>
<ul>
<li>Base class constructors are called <strong>before</strong> member initialization</li>
<li>Even if you write members first in the list:
<pre><code class="language-cpp">C() : c(3), B() { }  // B() still called before c initialization
</code></pre>
</li>
</ul>
<h3 id="best-practice"><a class="header" href="#best-practice">Best Practice</a></h3>
<p>âœ“ <strong>DO:</strong></p>
<ul>
<li>Explicitly call base constructors when you need specific initialization</li>
<li>Pass parameters through the hierarchy when needed</li>
<li>Use initializer lists for all initialization</li>
</ul>
<p>âœ— <strong>DON'T:</strong></p>
<ul>
<li>Rely on implicit default constructor calls when you need specific values</li>
<li>Try to initialize base class members in derived class constructor body</li>
<li>Forget that base constructors run first</li>
</ul>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p><strong>Constructor execution in inheritance</strong> follows a strict order:</p>
<ol>
<li>Base class constructor (outermost first)</li>
<li>Member variable initialization</li>
<li>Constructor body execution</li>
</ol>
<p><strong>If not explicitly called</strong>, the compiler automatically invokes the <strong>default constructor</strong> of the base class. To use parameterized base constructors, you must explicitly call them in the initializer list.</p>
<p>This ensures that the base class is fully constructed before the derived class tries to use it, maintaining the integrity of the inheritance hierarchy.</p>
<p><strong>C++11 introduced constructor inheritance</strong> using the <code>using</code> keyword, which allows derived classes to inherit base class constructors, reducing boilerplate code. However, there are important limitations when constructors with the same signature exist in both base and derived classes.</p>
<p><a href="#table-of-contents">â†‘ Back to Table of Contents</a></p>
<hr />
<p><a id="inheriting-constructors-cpp11"></a></p>
<h2 id="6-inheriting-constructors-c11"><a class="header" href="#6-inheriting-constructors-c11">6. Inheriting Constructors (C++11)</a></h2>
<h3 id="the-problem-before-c11"><a class="header" href="#the-problem-before-c11">The Problem Before C++11</a></h3>
<p>Before C++11, if you wanted to use base class constructors in a derived class, you had to write forwarding constructors manually:</p>
<pre><code class="language-cpp">class Base {
public:
    Base(int x) { }
    Base(int x, int y) { }
    Base(int x, int y, int z) { }
};

class Derived : public Base {
public:
    // Manually forward each constructor - tedious!
    Derived(int x) : Base(x) { }
    Derived(int x, int y) : Base(x, y) { }
    Derived(int x, int y, int z) : Base(x, y, z) { }
};
</code></pre>
<p><strong>Problems:</strong></p>
<ul>
<li>âŒ Lots of boilerplate code</li>
<li>âŒ Error-prone (easy to forget a constructor)</li>
<li>âŒ Hard to maintain (every base constructor needs forwarding)</li>
<li>âŒ Repetitive and tedious</li>
</ul>
<h3 id="the-solution-using-to-inherit-constructors-c11"><a class="header" href="#the-solution-using-to-inherit-constructors-c11">The Solution: <code>using</code> to Inherit Constructors (C++11)</a></h3>
<p>C++11 introduced the <code>using</code> declaration to inherit base class constructors:</p>
<pre><code class="language-cpp">class Base {
public:
    Base(int x) { std::cout &lt;&lt; "Base(int): " &lt;&lt; x &lt;&lt; "\n"; }
    Base(int x, int y) { std::cout &lt;&lt; "Base(int, int): " &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; "\n"; }
    Base(int x, int y, int z) { std::cout &lt;&lt; "Base(int, int, int)\n"; }
};

class Derived : public Base {
public:
    using Base::Base;  // âœ“ Inherit ALL base constructors!
};

int main() {
    Derived d1(10);           // Calls Base(int)
    Derived d2(10, 20);       // Calls Base(int, int)
    Derived d3(10, 20, 30);   // Calls Base(int, int, int)
}
</code></pre>
<h3 id="output-2"><a class="header" href="#output-2">Output</a></h3>
<pre><code>Base(int): 10
Base(int, int): 10, 20
Base(int, int, int)
</code></pre>
<h3 id="how-it-eases-development"><a class="header" href="#how-it-eases-development">How It Eases Development</a></h3>
<h4 id="before-c11-manual-forwarding"><a class="header" href="#before-c11-manual-forwarding">Before C++11 (Manual Forwarding)</a></h4>
<pre><code class="language-cpp">class Base {
public:
    Base() { }
    Base(int x) { }
    Base(int x, double y) { }
    Base(std::string s) { }
};

class Derived : public Base {
    int member;
public:
    // Must manually write ALL of these!
    Derived() : Base(), member(0) { }
    Derived(int x) : Base(x), member(0) { }
    Derived(int x, double y) : Base(x, y), member(0) { }
    Derived(std::string s) : Base(s), member(0) { }
};
</code></pre>
<h4 id="after-c11-inheriting-constructors"><a class="header" href="#after-c11-inheriting-constructors">After C++11 (Inheriting Constructors)</a></h4>
<pre><code class="language-cpp">class Base {
public:
    Base() { }
    Base(int x) { }
    Base(int x, double y) { }
    Base(std::string s) { }
};

class Derived : public Base {
    int member = 0;  // Default member initialization
public:
    using Base::Base;  // âœ“ One line instead of four constructors!
};
</code></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>âœ“ <strong>Less code</strong> - One line vs multiple constructors</li>
<li>âœ“ <strong>Less maintenance</strong> - Add base constructor, automatically available</li>
<li>âœ“ <strong>Fewer errors</strong> - No chance of forgetting to forward a constructor</li>
<li>âœ“ <strong>Cleaner code</strong> - Intent is clear and concise</li>
</ul>
<h3 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

class Person {
protected:
    std::string name;
    int age;
    
public:
    Person(std::string n) : name(n), age(0) {
        std::cout &lt;&lt; "Person(string): " &lt;&lt; name &lt;&lt; "\n";
    }
    
    Person(std::string n, int a) : name(n), age(a) {
        std::cout &lt;&lt; "Person(string, int): " &lt;&lt; name &lt;&lt; ", " &lt;&lt; age &lt;&lt; "\n";
    }
    
    void display() const {
        std::cout &lt;&lt; "Name: " &lt;&lt; name &lt;&lt; ", Age: " &lt;&lt; age &lt;&lt; "\n";
    }
};

class Employee : public Person {
    int employeeId = 0;  // Default member initialization
    
public:
    // Inherit all Person constructors
    using Person::Person;
    
    // Can still add derived-specific constructors
    Employee(std::string n, int a, int id) : Person(n, a), employeeId(id) {
        std::cout &lt;&lt; "Employee(string, int, int): " &lt;&lt; name &lt;&lt; ", " &lt;&lt; age &lt;&lt; ", " &lt;&lt; id &lt;&lt; "\n";
    }
    
    void display() const {
        Person::display();
        std::cout &lt;&lt; "Employee ID: " &lt;&lt; employeeId &lt;&lt; "\n";
    }
};

int main() {
    std::cout &lt;&lt; "=== Using inherited constructor ===" &lt;&lt; std::endl;
    Employee emp1("Alice", 30);
    emp1.display();
    
    std::cout &lt;&lt; "\n=== Using derived-specific constructor ===" &lt;&lt; std::endl;
    Employee emp2("Bob", 25, 1001);
    emp2.display();
    
    return 0;
}
</code></pre>
<h3 id="output-3"><a class="header" href="#output-3">Output</a></h3>
<pre><code>=== Using inherited constructor ===
Person(string, int): Alice, 30
Name: Alice, Age: 30
Employee ID: 0

=== Using derived-specific constructor ===
Person(string, int): Bob, 25
Employee(string, int, int): Bob, 25, 1001
Name: Bob, Age: 25
Employee ID: 1001
</code></pre>
<p><a href="#table-of-contents">â†‘ Back to Table of Contents</a></p>
<hr />
<p><a id="limitations-of-inherited-constructors"></a></p>
<h2 id="7-limitations-of-inherited-constructors"><a class="header" href="#7-limitations-of-inherited-constructors">7. Limitations of Inherited Constructors</a></h2>
<h3 id="limitation-1-constructor-hiding-same-signature-conflict"><a class="header" href="#limitation-1-constructor-hiding-same-signature-conflict">Limitation 1: Constructor Hiding (Same Signature Conflict)</a></h3>
<p><strong>Important Rule:</strong> If a derived class defines a constructor with the <strong>same signature</strong> as an inherited base constructor, the derived class constructor <strong>hides</strong> (overrides) the inherited one.</p>
<h4 id="example-constructor-hiding"><a class="header" href="#example-constructor-hiding">Example: Constructor Hiding</a></h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;

class Base {
public:
    Base(int x) {
        std::cout &lt;&lt; "Base(int): " &lt;&lt; x &lt;&lt; "\n";
    }
    
    Base(int x, int y) {
        std::cout &lt;&lt; "Base(int, int): " &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; "\n";
    }
};

class Derived : public Base {
public:
    using Base::Base;  // Inherit all Base constructors
    
    // This HIDES the inherited Base(int) constructor!
    Derived(int x) {
        std::cout &lt;&lt; "Derived(int): " &lt;&lt; x &lt;&lt; "\n";
    }
};

int main() {
    Derived d1(10);        // Calls Derived(int), NOT Base(int)
    Derived d2(10, 20);    // Calls inherited Base(int, int)
    
    return 0;
}
</code></pre>
<h3 id="output-4"><a class="header" href="#output-4">Output</a></h3>
<pre><code>Derived(int): 10
Base(int, int): 10, 20
</code></pre>
<h3 id="analysis"><a class="header" href="#analysis">Analysis</a></h3>
<pre><code>using Base::Base;  // Brings in:
                   // - Base(int)        â† HIDDEN by Derived(int)
                   // - Base(int, int)   â† Still available

Derived(int x) { }  // This HIDES Base(int)
</code></pre>
<p><strong>What Happens:</strong></p>
<ol>
<li><code>Derived d1(10)</code> - Calls <code>Derived(int)</code>, <strong>not</strong> the inherited <code>Base(int)</code></li>
<li><code>Derived d2(10, 20)</code> - Calls inherited <code>Base(int, int)</code> (no conflict)</li>
</ol>
<p><strong>Key Point:</strong> The derived class constructor with matching signature takes precedence and completely hides the inherited base constructor.</p>
<h3 id="detailed-example-with-multiple-scenarios"><a class="header" href="#detailed-example-with-multiple-scenarios">Detailed Example with Multiple Scenarios</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;

class Base {
public:
    Base() {
        std::cout &lt;&lt; "Base()\n";
    }
    
    Base(int x) {
        std::cout &lt;&lt; "Base(int): " &lt;&lt; x &lt;&lt; "\n";
    }
    
    Base(int x, int y) {
        std::cout &lt;&lt; "Base(int, int): " &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; "\n";
    }
    
    Base(double d) {
        std::cout &lt;&lt; "Base(double): " &lt;&lt; d &lt;&lt; "\n";
    }
};

class Derived : public Base {
    int member;
    
public:
    using Base::Base;  // Inherit ALL Base constructors
    
    // Scenario 1: Same signature - HIDES Base(int)
    Derived(int x) : Base(x * 2), member(x) {
        std::cout &lt;&lt; "Derived(int): " &lt;&lt; x &lt;&lt; ", member = " &lt;&lt; member &lt;&lt; "\n";
    }
    
    // Scenario 2: Different signature - coexists with inherited constructors
    Derived(int x, int y, int z) : Base(x, y), member(z) {
        std::cout &lt;&lt; "Derived(int, int, int): member = " &lt;&lt; z &lt;&lt; "\n";
    }
};

int main() {
    std::cout &lt;&lt; "=== Test 1: Derived(int) - Hidden ===" &lt;&lt; std::endl;
    Derived d1(5);  // Calls Derived(int), Base(int) is hidden
    
    std::cout &lt;&lt; "\n=== Test 2: Base(int, int) - Inherited ===" &lt;&lt; std::endl;
    Derived d2(10, 20);  // Calls inherited Base(int, int)
    
    std::cout &lt;&lt; "\n=== Test 3: Base(double) - Inherited ===" &lt;&lt; std::endl;
    Derived d3(3.14);  // Calls inherited Base(double)
    
    std::cout &lt;&lt; "\n=== Test 4: Derived(int, int, int) - Derived-specific ===" &lt;&lt; std::endl;
    Derived d4(1, 2, 3);  // Calls Derived(int, int, int)
    
    std::cout &lt;&lt; "\n=== Test 5: Base() - Inherited ===" &lt;&lt; std::endl;
    Derived d5;  // Calls inherited Base()
    
    return 0;
}
</code></pre>
<h3 id="output-5"><a class="header" href="#output-5">Output</a></h3>
<pre><code>=== Test 1: Derived(int) - Hidden ===
Base(int): 10
Derived(int): 5, member = 5

=== Test 2: Base(int, int) - Inherited ===
Base(int, int): 10, 20

=== Test 3: Base(double) - Inherited ===
Base(double): 3.14

=== Test 4: Derived(int, int, int) - Derived-specific ===
Base(int, int): 1, 2
Derived(int, int, int): member = 3

=== Test 5: Base() - Inherited ===
Base()
</code></pre>
<h3 id="analysis-of-each-test-case"><a class="header" href="#analysis-of-each-test-case">Analysis of Each Test Case</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Test</th><th>Constructor Called</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>Derived d1(5)</code></td><td><code>Derived(int)</code></td><td>Derived class has <code>Derived(int)</code> which <strong>hides</strong> inherited <code>Base(int)</code></td></tr>
<tr><td><code>Derived d2(10, 20)</code></td><td>Inherited <code>Base(int, int)</code></td><td>No conflict, uses inherited constructor</td></tr>
<tr><td><code>Derived d3(3.14)</code></td><td>Inherited <code>Base(double)</code></td><td>No conflict, uses inherited constructor</td></tr>
<tr><td><code>Derived d4(1, 2, 3)</code></td><td><code>Derived(int, int, int)</code></td><td>Derived-specific constructor (not inherited)</td></tr>
<tr><td><code>Derived d5</code></td><td>Inherited <code>Base()</code></td><td>No conflict, uses inherited constructor</td></tr>
</tbody></table>
</div>
<h3 id="limitation-2-cannot-inherit-from-multiple-bases-with-same-signature"><a class="header" href="#limitation-2-cannot-inherit-from-multiple-bases-with-same-signature">Limitation 2: Cannot Inherit from Multiple Bases with Same Signature</a></h3>
<p>If multiple base classes have constructors with the same signature, you cannot inherit them:</p>
<pre><code class="language-cpp">class Base1 {
public:
    Base1(int x) { }
};

class Base2 {
public:
    Base2(int x) { }
};

class Derived : public Base1, public Base2 {
public:
    using Base1::Base1;  // Brings Base1(int)
    using Base2::Base2;  // âŒ ERROR: Ambiguous - both have (int)
};
</code></pre>
<p><strong>Solution:</strong> Define your own constructor to resolve ambiguity:</p>
<pre><code class="language-cpp">class Derived : public Base1, public Base2 {
public:
    Derived(int x) : Base1(x), Base2(x) { }
};
</code></pre>
<h3 id="limitation-3-private-and-protected-constructors"><a class="header" href="#limitation-3-private-and-protected-constructors">Limitation 3: Private and Protected Constructors</a></h3>
<p>Inherited constructors maintain their access level:</p>
<pre><code class="language-cpp">class Base {
protected:
    Base(int x) { }  // Protected constructor
};

class Derived : public Base {
public:
    using Base::Base;  // Base(int) is still PROTECTED in Derived
};

int main() {
    // Derived d(10);  // âŒ ERROR: Base(int) is protected
}
</code></pre>
<h3 id="limitation-4-default-member-initialization"><a class="header" href="#limitation-4-default-member-initialization">Limitation 4: Default Member Initialization</a></h3>
<p>When using inherited constructors, derived class members must use <strong>default member initialization</strong>:</p>
<pre><code class="language-cpp">class Base {
public:
    Base(int x) { }
};

class Derived : public Base {
    int member;  // âŒ Uninitialized when using inherited constructors!
    
public:
    using Base::Base;
};

// Better:
class Derived : public Base {
    int member = 0;  // âœ“ Default member initialization
    
public:
    using Base::Base;
};
</code></pre>
<h3 id="when-not-to-use-inherited-constructors"><a class="header" href="#when-not-to-use-inherited-constructors">When NOT to Use Inherited Constructors</a></h3>
<p>âŒ <strong>Don't use inherited constructors when:</strong></p>
<ul>
<li>Derived class needs to initialize its own members in specific ways</li>
<li>You need different behavior than just forwarding to base</li>
<li>Multiple bases have constructors with same signature</li>
<li>You need to perform additional initialization logic</li>
</ul>
<p>âœ“ <strong>DO use inherited constructors when:</strong></p>
<ul>
<li>Derived class doesn't add new data members (or they have defaults)</li>
<li>You simply want to forward all base constructors</li>
<li>No special initialization logic is needed</li>
<li>You want to reduce boilerplate code</li>
</ul>
<h3 id="best-practices-summary"><a class="header" href="#best-practices-summary">Best Practices Summary</a></h3>
<pre><code class="language-cpp">class Base {
public:
    Base(int x) { }
    Base(int x, int y) { }
};

// âœ“ GOOD: Simple forwarding, members have defaults
class Derived1 : public Base {
    int member = 0;
public:
    using Base::Base;  // Clean and simple
};

// âœ“ GOOD: Mix inherited and custom constructors
class Derived2 : public Base {
    int member = 0;
public:
    using Base::Base;  // Inherit most constructors
    
    // Add custom constructor when needed
    Derived2(int x, int y, int z) : Base(x, y), member(z) { }
};

// âœ“ GOOD: Override when you need different behavior
class Derived3 : public Base {
    int member;
public:
    using Base::Base;  // Inherit Base(int, int)
    
    // Override Base(int) with custom behavior
    Derived3(int x) : Base(x * 2), member(x) { }
};

// âŒ BAD: Inherited constructors can't initialize this properly
class Derived4 : public Base {
    int member;  // No default, will be uninitialized!
public:
    using Base::Base;  // âŒ member not initialized
};
</code></pre>
<p><a href="#table-of-contents">â†‘ Back to Table of Contents</a></p>
<p><a id="destructors-order-inheritance"></a></p>
<h2 id="7understanding-destructor-execution-order"><a class="header" href="#7understanding-destructor-execution-order">7.Understanding Destructor Execution Order</a></h2>
<p>When an object of a <strong>derived class</strong> is destroyed, destructors are called in the <strong>reverse order of construction</strong>.</p>
<h3 id="-order-of-destruction"><a class="header" href="#-order-of-destruction">ğŸ§© Order of Destruction:</a></h3>
<ol>
<li><strong>Derived class destructor</strong> â€” called <strong>first</strong></li>
<li><strong>Base class destructor</strong> â€” called <strong>last</strong></li>
</ol>
<p>This ensures that the derived class cleans up its resources before the base class is destroyed.</p>
<hr />
<h3 id="-example-code"><a class="header" href="#-example-code">ğŸ“˜ Example Code</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;

class Parent {
public:
    Parent() { std::cout &lt;&lt; "Inside base class constructor\n"; }
    ~Parent() { std::cout &lt;&lt; "Inside base class destructor\n"; }
};

class Child : public Parent {
public:
    Child() { std::cout &lt;&lt; "Inside derived class constructor\n"; }
    ~Child() { std::cout &lt;&lt; "Inside derived class destructor\n"; }
};

int main() {
    Child obj;
    return 0;
}
</code></pre>
<hr />
<h3 id="-expected-output"><a class="header" href="#-expected-output">ğŸ–¥ï¸ Expected Output</a></h3>
<pre><code>Inside base class constructor
Inside derived class constructor
Inside derived class destructor
Inside base class destructor
</code></pre>
<hr />
<h3 id="-why-destructors-are-called-in-reverse-order"><a class="header" href="#-why-destructors-are-called-in-reverse-order">ğŸ’¡ Why Destructors Are Called in Reverse Order</a></h3>
<ul>
<li>During <strong>construction</strong>, the base class is created <strong>first</strong>, forming a foundation for the derived class.</li>
<li>During <strong>destruction</strong>, the <strong>derived destructor</strong> runs first to clean up resources that might depend on the base class still being valid.</li>
<li>After that, the <strong>base class destructor</strong> runs to finalize the cleanup.</li>
</ul>
<p>This reverse order:</p>
<ul>
<li>Prevents undefined behavior caused by destroying the base while derived resources still exist.</li>
<li>Maintains <strong>symmetry and safety</strong> â€” the baseâ€™s lifetime always outlasts the derived part.</li>
<li>Applies similarly to <strong>data members</strong>, which are also destroyed in the reverse order of their construction.</li>
</ul>
<hr />
<p><a href="#table-of-contents">â†‘ Back to Table of Contents</a></p>
<hr />
<h2 id="complete-summary"><a class="header" href="#complete-summary">Complete Summary</a></h2>
<h3 id="constructor-execution-rules"><a class="header" href="#constructor-execution-rules">Constructor Execution Rules</a></h3>
<ol>
<li><strong>Execution Order</strong>: Base â†’ Derived (construction), Derived â†’ Base (destruction)</li>
<li><strong>Default Constructor</strong>: Automatically called if not explicitly specified</li>
<li><strong>Explicit Calls</strong>: Use initializer list to call specific base constructors</li>
<li><strong>C++11 Inheritance</strong>: Use <code>using Base::Base;</code> to inherit all base constructors</li>
</ol>
<h3 id="inheriting-constructors-c11"><a class="header" href="#inheriting-constructors-c11">Inheriting Constructors (C++11)</a></h3>
<p><strong>Advantages:</strong></p>
<ul>
<li>âœ“ Reduces boilerplate code</li>
<li>âœ“ Automatic forwarding of base constructors</li>
<li>âœ“ Easier maintenance</li>
<li>âœ“ Less error-prone</li>
</ul>
<p><strong>Limitations:</strong></p>
<ul>
<li>âš ï¸ Same signature in derived class hides inherited constructor</li>
<li>âš ï¸ Cannot inherit from multiple bases with same signature</li>
<li>âš ï¸ Access levels are preserved</li>
<li>âš ï¸ Derived members need default initialization</li>
</ul>
<p><strong>Golden Rule:</strong> Inherited constructors are a convenience feature for simple cases. When you need custom initialization logic, write explicit constructors.</p>
<h3 id="destructor-execution-order"><a class="header" href="#destructor-execution-order">Destructor execution order</a></h3>
<p>The <strong>reverse order of destructor calls</strong> ensures:</p>
<ul>
<li>Consistent and safe cleanup</li>
<li>Proper handling of dependencies</li>
<li>No premature destruction of essential components</li>
</ul>
<p>In short, <strong>destruction happens bottom-up</strong>, mirroring the <strong>top-down</strong> order of construction.</p>
<p><a href="#table-of-contents">â†‘ Back to Table of Contents</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="constructor.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="static.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="constructor.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="static.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
