<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pointers</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-1a9297dc.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-1f29a5bd.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/sagardesd/Cpp-ebook" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="c-pointers--dynamic-memory-allocation---complete-tutorial"><a class="header" href="#c-pointers--dynamic-memory-allocation---complete-tutorial">C++ Pointers &amp; Dynamic Memory Allocation - Complete Tutorial</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ol>
<li><a href="#1-introduction-to-pointers">Introduction to Pointers</a></li>
<li><a href="#2-how-dereferencing-works">How Dereferencing Works</a></li>
<li><a href="#3-dynamic-memory-allocation">Dynamic Memory Allocation</a></li>
<li><a href="#4-void-pointers">Void Pointers</a></li>
<li><a href="#5-pointer-size">Pointer Size</a></li>
<li><a href="#6-arrays-and-pointers">Arrays and Pointers</a></li>
<li><a href="#7-const-pointers-variations">Const Pointers Variations</a></li>
<li><a href="#8-breaking-constantness">Breaking Constantness</a></li>
<li><a href="#9-placement-new-operator">Placement New Operator</a></li>
<li><a href="#10-best-practices">Best Practices</a></li>
<li><a href="#11-common-bugs">Common Bugs</a></li>
</ol>
<hr>
<h2 id="1-introduction-to-pointers"><a class="header" href="#1-introduction-to-pointers">1. Introduction to Pointers</a></h2>
<h3 id="c-pointer-basics"><a class="header" href="#c-pointer-basics">C++ Pointer Basics</a></h3>
<p>A <strong>pointer</strong> is a variable that stores the memory address of another variable.</p>
<pre><code class="language-cpp">int value = 42;
int* ptr = &amp;value;  // ptr stores the address of value

std::cout &lt;&lt; "Value: " &lt;&lt; value &lt;&lt; std::endl;           // Output: 42
std::cout &lt;&lt; "Address of value: " &lt;&lt; &amp;value &lt;&lt; std::endl;  // Output: 0x7ffc12345678
std::cout &lt;&lt; "Pointer ptr: " &lt;&lt; ptr &lt;&lt; std::endl;       // Output: 0x7ffc12345678
std::cout &lt;&lt; "Dereferenced ptr: " &lt;&lt; *ptr &lt;&lt; std::endl; // Output: 42
</code></pre>
<p><strong>Key Operators:</strong></p>
<ul>
<li><code>&amp;</code> (address-of operator): Gets the memory address of a variable</li>
<li><code>*</code> (dereference operator): Accesses the value at the address stored in the pointer</li>
</ul>
<h3 id="real-life-analogy-home-addresses"><a class="header" href="#real-life-analogy-home-addresses">Real-Life Analogy: Home Addresses</a></h3>
<p>Think of computer memory like a street with houses. Each house has:</p>
<ul>
<li><strong>An address</strong> (like “123 Main Street”) - this is the memory address</li>
<li><strong>Contents inside</strong> (furniture, people, etc.) - this is the actual data</li>
<li><strong>A mailbox with the address written on it</strong> - this is the pointer</li>
</ul>
<pre><code>Real Life:                          Computer Memory:
┌─────────────────────────┐        ┌─────────────────────────┐
│  123 Main Street        │        │  Memory Address: 0x1000 │
│  ┌─────────────────┐    │        │  ┌─────────────────┐    │
│  │  John's House   │    │        │  │  Value: 42      │    │
│  │  (The actual    │    │        │  │  (The actual    │    │
│  │   person/data)  │    │        │  │   data)         │    │
│  └─────────────────┘    │        │  └─────────────────┘    │
└─────────────────────────┘        └─────────────────────────┘

Your Friend's Note:                 Your Pointer Variable:
┌─────────────────────────┐        ┌─────────────────────────┐
│ "John lives at          │        │  int* ptr = 0x1000;     │
│  123 Main Street"       │        │                         │
│  (The address, not      │        │  (The address, not      │
│   the person!)          │        │   the value!)           │
└─────────────────────────┘        └─────────────────────────┘
</code></pre>
<p><strong>Key Insights from the Analogy:</strong></p>
<ol>
<li>
<p><strong>Address vs Contents:</strong></p>
<ul>
<li>When someone gives you an address “123 Main Street”, they’re not giving you the house or John - just the location</li>
<li>When a pointer stores <code>0x1000</code>, it’s not storing the value <code>42</code> - just the location</li>
</ul>
</li>
<li>
<p><strong>Using the Address (Dereferencing):</strong></p>
<ul>
<li>If you want to visit John, you go to “123 Main Street” and knock on the door</li>
<li>If you want the value, you dereference <code>*ptr</code> (go to address <code>0x1000</code> and get the data)</li>
</ul>
</li>
<li>
<p><strong>Multiple References:</strong></p>
<ul>
<li>You can have many notes with the same address “123 Main Street”</li>
<li>You can have many pointers to the same memory address</li>
</ul>
</li>
<li>
<p><strong>Changing the Address:</strong></p>
<ul>
<li>You can update your note to point to a different house: <del>123 Main Street</del> → 456 Oak Avenue</li>
<li>You can change what a pointer points to: <code>ptr = &amp;another_variable;</code></li>
</ul>
</li>
<li>
<p><strong>nullptr is like “No Address”:</strong></p>
<ul>
<li>A blank note with no address written on it</li>
<li>You can’t visit a house if you don’t have an address!</li>
</ul>
</li>
</ol>
<h3 id="extending-the-analogy"><a class="header" href="#extending-the-analogy">Extending the Analogy:</a></h3>
<pre><code class="language-cpp">// Real Life                          // Code
int john_age = 25;                    // John (age 25) lives at 123 Main St
int* address_note = &amp;john_age;        // Write down John's address on a note

std::cout &lt;&lt; address_note;            // Read the note: "123 Main Street"
std::cout &lt;&lt; *address_note;           // Go to that address, find John: age 25

*address_note = 26;                   // Go to 123 Main St, update John's age to 26
// john_age is now 26!                // John's actual age changed!

int mary_age = 30;                    // Mary (age 30) lives at 456 Oak Ave
address_note = &amp;mary_age;             // Update the note to Mary's address
// Now the note points to Mary's house instead of John's house
</code></pre>
<h3 id="what-happens-without-pointers"><a class="header" href="#what-happens-without-pointers">What Happens Without Pointers?</a></h3>
<pre><code class="language-cpp">// Without pointer (making a copy)    // Real Life Analogy
int john_age = 25;                    // John is 25 years old
int copy_of_age = john_age;          // You write "25" on a paper (copy)

copy_of_age = 26;                     // You change the paper to "26"
// john_age is STILL 25!              // But John is STILL 25 years old!
                                      // You only changed your copy

// With pointer (reference)           // Real Life Analogy
int john_age = 25;                    // John is 25 years old
int* ptr = &amp;john_age;                // You write down John's address

*ptr = 26;                            // Go to John's house and change his age
// john_age is NOW 26!                // John himself is now 26!
</code></pre>
<h3 id="why-pointers-are-useful"><a class="header" href="#why-pointers-are-useful">Why Pointers Are Useful:</a></h3>
<ol>
<li>
<p><strong>Efficiency (Sending Just the Address):</strong></p>
<pre><code>Real Life: Instead of copying an entire book to send to someone,
           you send them the library address and shelf number

Code: Instead of copying 1GB of data, you pass a pointer (8 bytes)
</code></pre>
</li>
<li>
<p><strong>Shared Access:</strong></p>
<pre><code>Real Life: Multiple people can have the same address and visit
           the same house

Code: Multiple pointers can reference the same data
</code></pre>
</li>
<li>
<p><strong>Dynamic Allocation:</strong></p>
<pre><code>Real Life: Building a new house when you need it (new construction)
           and tearing it down when done (demolition)

Code: Allocating memory with 'new' when needed
      and freeing it with 'delete' when done
</code></pre>
</li>
</ol>
<p><a href="#table-of-contents">↑ Back to Table of Contents</a></p>
<hr>
<h2 id="2-how-dereferencing-works"><a class="header" href="#2-how-dereferencing-works">2. How Dereferencing Works</a></h2>
<p>Dereferencing is the process of accessing the value stored at the memory address held by a pointer.</p>
<h3 id="step-by-step-process"><a class="header" href="#step-by-step-process">Step-by-Step Process:</a></h3>
<pre><code>Memory Layout:
┌─────────────┬──────────┬─────────────┐
│  Address    │   Data   │  Variable   │
├─────────────┼──────────┼─────────────┤
│ 0x1000      │    42    │   value     │
│ 0x1004      │  0x1000  │   ptr       │
└─────────────┴──────────┴─────────────┘
</code></pre>
<p><strong>When you dereference <code>*ptr</code>:</strong></p>
<ol>
<li><strong>Step 1:</strong> CPU reads the pointer variable <code>ptr</code> → Gets address <code>0x1000</code></li>
<li><strong>Step 2:</strong> CPU goes to memory location <code>0x1000</code></li>
<li><strong>Step 3:</strong> Uses the data type (<code>int</code>) to determine how many bytes to read (4 bytes for int)</li>
<li><strong>Step 4:</strong> Reads 4 bytes starting from <code>0x1000</code> → Gets value <code>42</code></li>
<li><strong>Step 5:</strong> Returns the value <code>42</code></li>
</ol>
<h3 id="visual-representation"><a class="header" href="#visual-representation">Visual Representation:</a></h3>
<pre><code>int value = 42;        // Located at address 0x1000
int* ptr = &amp;value;     // ptr contains 0x1000

Memory View:
┌──────────────────────────────────────┐
│  Address: 0x1000                     │
│  ┌────┬────┬────┬────┐               │
│  │ 42 │ 00 │ 00 │ 00 │  (4 bytes)    │ ← value
│  └────┴────┴────┴────┘               │
└──────────────────────────────────────┘
        ↑
        │
    ┌───┴────┐
    │  ptr   │ (stores 0x1000)
    └────────┘

*ptr operation:
1. Read ptr       → 0x1000
2. Go to 0x1000   → Find memory location
3. Type is int    → Read 4 bytes
4. Fetch data     → 42
</code></pre>
<h3 id="example-with-different-data-types"><a class="header" href="#example-with-different-data-types">Example with Different Data Types:</a></h3>
<pre><code class="language-cpp">// Different types require different byte reads
char c = 'A';        // 1 byte
short s = 1000;      // 2 bytes
int i = 50000;       // 4 bytes
long long ll = 1e15; // 8 bytes
double d = 3.14;     // 8 bytes

char* ptr_c = &amp;c;         // When dereferencing, read 1 byte
short* ptr_s = &amp;s;        // When dereferencing, read 2 bytes
int* ptr_i = &amp;i;          // When dereferencing, read 4 bytes
long long* ptr_ll = &amp;ll;  // When dereferencing, read 8 bytes
double* ptr_d = &amp;d;       // When dereferencing, read 8 bytes
</code></pre>
<p><a href="#table-of-contents">↑ Back to Table of Contents</a></p>
<hr>
<h2 id="3-dynamic-memory-allocation"><a class="header" href="#3-dynamic-memory-allocation">3. Dynamic Memory Allocation</a></h2>
<p>Dynamic memory is allocated on the <strong>heap</strong> at runtime using <code>new</code> and must be manually freed using <code>delete</code>.</p>
<h3 id="using-new-and-delete"><a class="header" href="#using-new-and-delete">Using <code>new</code> and <code>delete</code></a></h3>
<pre><code class="language-cpp">// Single object allocation
int* ptr = new int;        // Allocate memory for one int
*ptr = 100;                // Assign value
std::cout &lt;&lt; *ptr &lt;&lt; std::endl;
delete ptr;                // Free memory
ptr = nullptr;             // Good practice: nullify after delete

// Allocate with initialization
int* ptr2 = new int(42);   // Allocate and initialize to 42
delete ptr2;

// Array allocation
int* arr = new int[5];     // Allocate array of 5 ints
arr[0] = 10;
arr[1] = 20;
delete[] arr;              // Must use delete[] for arrays
arr = nullptr;
</code></pre>
<h3 id="memory-layout-stack-vs-heap"><a class="header" href="#memory-layout-stack-vs-heap">Memory Layout: Stack vs Heap</a></h3>
<pre><code>Stack (automatic storage):          Heap (dynamic storage):
┌─────────────────────┐            ┌─────────────────────┐
│  int x = 10;        │            │  new int(42)        │
│  [cleaned up auto]  │            │  [manual cleanup]   │
│                     │            │                     │
│  Limited size       │            │  Large size         │
│  Fast access        │            │  Slower access      │
│  LIFO structure     │            │  Fragmented         │
└─────────────────────┘            └─────────────────────┘
</code></pre>
<h3 id="key-differences"><a class="header" href="#key-differences">Key Differences:</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Stack</th><th>Heap</th></tr>
</thead>
<tbody>
<tr><td>Allocation</td><td>Automatic</td><td>Manual (new)</td></tr>
<tr><td>Deallocation</td><td>Automatic</td><td>Manual (delete)</td></tr>
<tr><td>Size</td><td>Limited (~1-8MB)</td><td>Large (GB)</td></tr>
<tr><td>Speed</td><td>Faster</td><td>Slower</td></tr>
<tr><td>Lifetime</td><td>Scope-based</td><td>Until delete</td></tr>
</tbody>
</table>
</div>
<p><a href="#table-of-contents">↑ Back to Table of Contents</a></p>
<hr>
<h2 id="4-void-pointers"><a class="header" href="#4-void-pointers">4. Void Pointers</a></h2>
<p>A <code>void*</code> is a <strong>generic pointer</strong> that can point to any data type but cannot be dereferenced directly.</p>
<pre><code class="language-cpp">void* void_ptr;
int x = 42;
double y = 3.14;
char c = 'A';

// void* can point to any type
void_ptr = &amp;x;
void_ptr = &amp;y;
void_ptr = &amp;c;

// ERROR: Cannot dereference void*
// std::cout &lt;&lt; *void_ptr &lt;&lt; std::endl;  // Compiler error!

// Must cast to specific type before dereferencing
void_ptr = &amp;x;
int value = *(static_cast&lt;int*&gt;(void_ptr));  // OK: Cast then dereference
std::cout &lt;&lt; value &lt;&lt; std::endl;  // Output: 42
</code></pre>
<h3 id="common-use-cases"><a class="header" href="#common-use-cases">Common Use Cases:</a></h3>
<pre><code class="language-cpp">// 1. Generic memory allocation functions
void* malloc(size_t size);  // C-style allocation returns void*

// 2. Generic callback functions
void process_data(void* data, void (*callback)(void*)) {
    callback(data);
}

// 3. Type-erased storage
void* user_data = new UserData();
// Later cast back: auto* ud = static_cast&lt;UserData*&gt;(user_data);
</code></pre>
<h3 id="important-notes"><a class="header" href="#important-notes">Important Notes:</a></h3>
<ul>
<li>Cannot perform pointer arithmetic on <code>void*</code></li>
<li>Cannot dereference without casting</li>
<li>Type safety is programmer’s responsibility</li>
<li>Modern C++ prefers templates over void pointers</li>
</ul>
<p><a href="#table-of-contents">↑ Back to Table of Contents</a></p>
<hr>
<h2 id="5-pointer-size"><a class="header" href="#5-pointer-size">5. Pointer Size</a></h2>
<p>The size of a pointer depends on the <strong>system architecture</strong>, not the data type it points to.</p>
<pre><code class="language-cpp">// On 64-bit systems: all pointers are 8 bytes
// On 32-bit systems: all pointers are 4 bytes

char* ptr_char;
int* ptr_int;
double* ptr_double;
long long* ptr_ll;
void* ptr_void;

std::cout &lt;&lt; "Size of char*:      " &lt;&lt; sizeof(ptr_char) &lt;&lt; std::endl;    // 8 on 64-bit
std::cout &lt;&lt; "Size of int*:       " &lt;&lt; sizeof(ptr_int) &lt;&lt; std::endl;     // 8 on 64-bit
std::cout &lt;&lt; "Size of double*:    " &lt;&lt; sizeof(ptr_double) &lt;&lt; std::endl;  // 8 on 64-bit
std::cout &lt;&lt; "Size of long long*: " &lt;&lt; sizeof(ptr_ll) &lt;&lt; std::endl;      // 8 on 64-bit
std::cout &lt;&lt; "Size of void*:      " &lt;&lt; sizeof(ptr_void) &lt;&lt; std::endl;    // 8 on 64-bit

// All output: 8 bytes on 64-bit system
</code></pre>
<h3 id="why-all-pointers-are-the-same-size"><a class="header" href="#why-all-pointers-are-the-same-size">Why All Pointers Are The Same Size:</a></h3>
<pre><code>A pointer is just a memory address:

32-bit system:
  Address space: 0x00000000 to 0xFFFFFFFF
  Pointer size: 4 bytes (32 bits)
  
64-bit system:
  Address space: 0x0000000000000000 to 0xFFFFFFFFFFFFFFFF
  Pointer size: 8 bytes (64 bits)

The data type tells the compiler:
  - How many bytes to read when dereferencing
  - How much to increment/decrement in pointer arithmetic
  
But the address itself is always the same size!
</code></pre>
<h3 id="pointer-arithmetic-depends-on-type"><a class="header" href="#pointer-arithmetic-depends-on-type">Pointer Arithmetic Depends on Type:</a></h3>
<pre><code class="language-cpp">int arr[5] = {10, 20, 30, 40, 50};
int* ptr = arr;

std::cout &lt;&lt; ptr &lt;&lt; std::endl;      // e.g., 0x1000
std::cout &lt;&lt; ptr + 1 &lt;&lt; std::endl;  // 0x1004 (increments by sizeof(int) = 4)

char* c_ptr = reinterpret_cast&lt;char*&gt;(arr);
std::cout &lt;&lt; c_ptr &lt;&lt; std::endl;      // 0x1000
std::cout &lt;&lt; c_ptr + 1 &lt;&lt; std::endl;  // 0x1001 (increments by sizeof(char) = 1)
</code></pre>
<p><a href="#table-of-contents">↑ Back to Table of Contents</a></p>
<hr>
<h2 id="6-arrays-and-pointers"><a class="header" href="#6-arrays-and-pointers">6. Arrays and Pointers</a></h2>
<h3 id="real-life-analogy-apartment-building"><a class="header" href="#real-life-analogy-apartment-building">Real-Life Analogy: Apartment Building</a></h3>
<p>Think of an array as an apartment building where:</p>
<ul>
<li>The <strong>building address</strong> is like the array name (constant, never changes)</li>
<li>Each <strong>apartment</strong> is an array element</li>
<li><strong>Apartment numbers</strong> (1, 2, 3…) are like array indices</li>
</ul>
<pre><code>Apartment Building:                  Array in Memory:
┌────────────────────────────┐      ┌────────────────────────────┐
│ "Sunset Towers"            │      │ int arr[5]                 │
│ Located at 100 Main St     │      │ Located at 0x1000          │
│ (Building address is FIXED)│      │ (Array name is FIXED)      │
│                            │      │                            │
│ Apt #1: John (age 25)      │      │ arr[0]: 10                 │
│ Apt #2: Mary (age 30)      │      │ arr[1]: 20                 │
│ Apt #3: Bob  (age 35)      │      │ arr[2]: 30                 │
│ Apt #4: Sue  (age 40)      │      │ arr[3]: 40                 │
│ Apt #5: Tom  (age 45)      │      │ arr[4]: 50                 │
└────────────────────────────┘      └────────────────────────────┘

Building Address: 100 Main St       Array Name: arr
  - CANNOT change to different        - CANNOT change to point to
    street address                      different memory location
  - It's a PERMANENT landmark         - It's a CONSTANT POINTER
  
Apartment #1 is at:                 First element at:
  100 Main St, Apt #1                 arr + 0 = 0x1000
  
Apartment #3 is at:                 Third element at:
  100 Main St, Apt #3                 arr + 2 = 0x1008
</code></pre>
<h3 id="why-array-names-are-constant"><a class="header" href="#why-array-names-are-constant">Why Array Names Are Constant:</a></h3>
<pre><code class="language-cpp">// Real Life                           // Code
int arr[5] = {10, 20, 30, 40, 50};    // Build "Sunset Towers" at 100 Main St

// You CAN: Change what's inside apartments
arr[0] = 100;                         // Renovate Apt #1

// You CAN: Get a notecard with building address
int* ptr = arr;                       // Write "100 Main St" on a note
ptr++;                                // Update note to "100 Main St, Apt #2"

// You CANNOT: Move the entire building!
// arr = arr + 1;  ❌ ERROR!            // Can't relocate Sunset Towers!
// arr++;          ❌ ERROR!            // Buildings don't move!

int other[3] = {1, 2, 3};             // Different building: "Oak Plaza"
// arr = other;    ❌ ERROR!            // Can't make Sunset Towers become Oak Plaza!
</code></pre>
<h3 id="pointer-vs-array-name"><a class="header" href="#pointer-vs-array-name">Pointer vs Array Name:</a></h3>
<pre><code>Scenario: You have two notecards

NOTECARD 1 (Array Name - "arr"):
┌─────────────────────────────────┐
│ "Sunset Towers is permanently   │
│  located at 100 Main Street"    │
│                                 │
│ ❌ You CANNOT erase this and     │
│    write a different address    │
│ ✓ You CAN visit any apartment   │
└─────────────────────────────────┘

NOTECARD 2 (Pointer - "ptr"):
┌─────────────────────────────────┐
│ "Current location: 100 Main St" │
│                                 │
│ ✓ You CAN erase and write:      │
│   "Current location: 456 Oak"   │
│ ✓ You CAN visit any apartment   │
└─────────────────────────────────┘
</code></pre>
<h3 id="arrays-and-pointers"><a class="header" href="#arrays-and-pointers">Arrays and Pointers</a></h3>
<h3 id="array-name-as-a-constant-pointer"><a class="header" href="#array-name-as-a-constant-pointer">Array Name as a Constant Pointer</a></h3>
<p>When you declare an array, the array name acts like a <strong>constant pointer</strong> to the first element.</p>
<pre><code class="language-cpp">int arr[5] = {10, 20, 30, 40, 50};

// arr is equivalent to &amp;arr[0]
std::cout &lt;&lt; "Array name (arr):        " &lt;&lt; arr &lt;&lt; std::endl;         // e.g., 0x1000
std::cout &lt;&lt; "Address of first elem:   " &lt;&lt; &amp;arr[0] &lt;&lt; std::endl;    // e.g., 0x1000
std::cout &lt;&lt; "First element (*arr):    " &lt;&lt; *arr &lt;&lt; std::endl;        // 10
std::cout &lt;&lt; "First element (arr[0]):  " &lt;&lt; arr[0] &lt;&lt; std::endl;      // 10
</code></pre>
<h3 id="memory-layout-of-arrays"><a class="header" href="#memory-layout-of-arrays">Memory Layout of Arrays:</a></h3>
<pre><code>Array: int arr[5] = {10, 20, 30, 40, 50};

Memory View:
┌─────────┬─────────┬─────────┬─────────┬─────────┐
│   10    │   20    │   30    │   40    │   50    │
└─────────┴─────────┴─────────┴─────────┴─────────┘
↑         ↑         ↑         ↑         ↑
0x1000    0x1004    0x1008    0x100C    0x1010
│
arr (points here, FIXED location)

arr[0] ≡ *(arr + 0) ≡ *arr
arr[1] ≡ *(arr + 1)
arr[2] ≡ *(arr + 2)
arr[3] ≡ *(arr + 3)
arr[4] ≡ *(arr + 4)
</code></pre>
<h3 id="array-vs-pointer-key-difference"><a class="header" href="#array-vs-pointer-key-difference">Array vs Pointer: Key Difference</a></h3>
<pre><code class="language-cpp">int arr[5] = {10, 20, 30, 40, 50};
int* ptr = arr;  // ptr points to first element

// Similarities:
std::cout &lt;&lt; arr[2] &lt;&lt; std::endl;    // 30
std::cout &lt;&lt; ptr[2] &lt;&lt; std::endl;    // 30
std::cout &lt;&lt; *(arr + 2) &lt;&lt; std::endl; // 30
std::cout &lt;&lt; *(ptr + 2) &lt;&lt; std::endl; // 30

// KEY DIFFERENCE: arr is a CONSTANT POINTER
ptr = ptr + 1;     // OK: ptr can be reassigned
// arr = arr + 1;  // ERROR: arr is a constant pointer!

int another[3] = {1, 2, 3};
ptr = another;     // OK: ptr can point to different array
// arr = another;  // ERROR: Cannot reassign arr!
</code></pre>
<h3 id="why-array-name-is-a-constant-pointer"><a class="header" href="#why-array-name-is-a-constant-pointer">Why Array Name is a Constant Pointer:</a></h3>
<pre><code class="language-cpp">int arr[5] = {10, 20, 30, 40, 50};

// Think of arr as:
// int* const arr = &lt;address of first element&gt;;

// This is why you CAN:
*arr = 100;        // Modify the value at arr[0]
*(arr + 1) = 200;  // Modify the value at arr[1]

// But you CANNOT:
// arr = arr + 1;     // Change where arr points
// arr++;             // Increment arr
// int other[3];
// arr = other;       // Point arr to different array

// However, a pointer TO the array can be changed:
int* ptr = arr;
ptr++;             // OK: ptr now points to arr[1]
ptr = arr;         // OK: Reset ptr to point to arr[0]
</code></pre>
<h3 id="visualization"><a class="header" href="#visualization">Visualization:</a></h3>
<pre><code>Stack Memory:
┌─────────────────────────────────────┐
│  int arr[5] = {10, 20, 30, ...};    │
│  ┌────┬────┬────┬────┬────┐         │
│  │ 10 │ 20 │ 30 │ 40 │ 50 │         │
│  └────┴────┴────┴────┴────┘         │
│   ↑                                 │
│   │ arr (CONSTANT - can't change)   │
│   │                                 │
│  ┌┴──────┐                          │
│  │  ptr  │ (VARIABLE - can change)  │
│  └───────┘                          │
│   ↓                                 │
│  Can be reassigned to point         │
│  anywhere                           │
└─────────────────────────────────────┘
</code></pre>
<h3 id="dynamic-array-allocation"><a class="header" href="#dynamic-array-allocation">Dynamic Array Allocation</a></h3>
<p>Unlike static arrays, dynamically allocated arrays use pointers that CAN be reassigned.</p>
<h4 id="allocating-dynamic-arrays"><a class="header" href="#allocating-dynamic-arrays">Allocating Dynamic Arrays:</a></h4>
<pre><code class="language-cpp">// Allocate array of 5 integers
int* arr = new int[5];

// Initialize values
arr[0] = 10;
arr[1] = 20;
arr[2] = 30;
arr[3] = 40;
arr[4] = 50;

// Access like normal array
for (int i = 0; i &lt; 5; i++) {
    std::cout &lt;&lt; arr[i] &lt;&lt; " ";
}
std::cout &lt;&lt; std::endl;

// IMPORTANT: Must use delete[] for arrays
delete[] arr;
arr = nullptr;
</code></pre>
<h4 id="allocate-with-initialization"><a class="header" href="#allocate-with-initialization">Allocate with Initialization:</a></h4>
<pre><code class="language-cpp">// C++11 and later: Initialize with values
int* arr = new int[5]{10, 20, 30, 40, 50};

// Zero-initialize
int* zeros = new int[5]();  // All elements set to 0

// Default-initialize (garbage values for primitives)
int* uninitialized = new int[5];

// Cleanup
delete[] arr;
delete[] zeros;
delete[] uninitialized;
</code></pre>
<h4 id="dynamic-array-memory-layout"><a class="header" href="#dynamic-array-memory-layout">Dynamic Array Memory Layout:</a></h4>
<pre><code>Stack:                          Heap:
┌─────────────┐                ┌────┬────┬────┬────┬────┐
│  int* arr   │ ───────────────&gt;│ 10 │ 20 │ 30 │ 40 │ 50 │
│  (8 bytes)  │                └────┴────┴────┴────┴────┘
└─────────────┘                (20 bytes allocated)
     │
     │ Can be reassigned!
     ▼
┌────────────────┐
│ arr = new ...  │  OK: This is a regular pointer
└────────────────┘
</code></pre>
<h3 id="deallocating-arrays-delete-vs-delete"><a class="header" href="#deallocating-arrays-delete-vs-delete">Deallocating Arrays: delete vs delete[]</a></h3>
<p><strong>CRITICAL:</strong> Always use <code>delete[]</code> for arrays allocated with <code>new[]</code>.</p>
<pre><code class="language-cpp">// Single object
int* ptr = new int(42);
delete ptr;  // Correct: Use delete for single object

// Array
int* arr = new int[10];
delete[] arr;  // Correct: Use delete[] for arrays

// WRONG - Undefined Behavior:
int* arr2 = new int[10];
delete arr2;  // BUG: Should be delete[]
              // May corrupt heap, leak memory, or crash

int* ptr2 = new int(42);
delete[] ptr2;  // BUG: Should be delete
                // Undefined behavior
</code></pre>
<h4 id="why-delete-is-necessary"><a class="header" href="#why-delete-is-necessary">Why delete[] is Necessary:</a></h4>
<pre><code>When you use new[]:
┌────────────────────────────────────┐
│ [hidden size info] [10] [20] [30]  │
└────────────────────────────────────┘
         ↑              ↑
         │              └─ Your pointer points here
         └─ Compiler stores array size here

delete[] knows to:
1. Call destructor for each element (for objects)
2. Read the hidden size information
3. Deallocate the entire block

delete (wrong) will:
1. Call destructor only once
2. Deallocate wrong amount of memory
3. Cause undefined behavior
</code></pre>
<h4 id="example-with-objects"><a class="header" href="#example-with-objects">Example with Objects:</a></h4>
<pre><code class="language-cpp">class MyClass {
public:
    MyClass() { std::cout &lt;&lt; "Constructor" &lt;&lt; std::endl; }
    ~MyClass() { std::cout &lt;&lt; "Destructor" &lt;&lt; std::endl; }
};

// Allocate array of objects
MyClass* arr = new MyClass[3];
// Output:
// Constructor
// Constructor
// Constructor

delete[] arr;  // Calls destructor for ALL 3 objects
// Output:
// Destructor
// Destructor
// Destructor

// If you mistakenly use delete instead of delete[]:
MyClass* arr2 = new MyClass[3];
delete arr2;  // BUG: Only calls destructor ONCE!
              // Other 2 objects not properly destroyed
</code></pre>
<h3 id="passing-arrays-to-functions"><a class="header" href="#passing-arrays-to-functions">Passing Arrays to Functions</a></h3>
<p>When you pass an array to a function, it <strong>decays to a pointer</strong>. The size information is lost!</p>
<h4 id="array-decay"><a class="header" href="#array-decay">Array Decay:</a></h4>
<pre><code class="language-cpp">void print_array(int arr[], int size) {  // arr[] decays to int*
    std::cout &lt;&lt; "Inside function, sizeof(arr): " &lt;&lt; sizeof(arr) &lt;&lt; std::endl;
    // Output: 8 (size of pointer, not array!)
    
    for (int i = 0; i &lt; size; i++) {
        std::cout &lt;&lt; arr[i] &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
}

int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    
    std::cout &lt;&lt; "In main, sizeof(arr): " &lt;&lt; sizeof(arr) &lt;&lt; std::endl;
    // Output: 20 (5 elements × 4 bytes each)
    
    print_array(arr, 5);  // Must pass size separately!
    
    return 0;
}
</code></pre>
<h4 id="why-you-need-to-pass-size"><a class="header" href="#why-you-need-to-pass-size">Why You Need to Pass Size:</a></h4>
<pre><code>In main():
┌─────────────────────────────────────┐
│  int arr[5] = {10, 20, 30, 40, 50}; │
│                                     │
│  sizeof(arr) = 20 bytes             │
│  Compiler KNOWS it's 5 elements     │
└─────────────────────────────────────┘

When passed to function:
┌─────────────────────────────────────┐
│  void func(int arr[])               │
│                                     │
│  arr is now just int*               │
│  sizeof(arr) = 8 (pointer size)     │
│  No size information!               │
│  Could point to 1, 5, 100 elements  │
└─────────────────────────────────────┘

Solution: Pass size explicitly!
func(arr, 5);
</code></pre>
<h4 id="different-ways-to-pass-arrays"><a class="header" href="#different-ways-to-pass-arrays">Different Ways to Pass Arrays:</a></h4>
<pre><code class="language-cpp">// Method 1: Array notation (still decays to pointer)
void func1(int arr[], int size) {
    // arr is int*
}

// Method 2: Pointer notation (equivalent to method 1)
void func2(int* arr, int size) {
    // More honest about what it is
}

// Method 3: Reference to array (preserves size!)
void func3(int (&amp;arr)[5]) {
    // Size is part of type - no decay!
    // But only works for arrays of exactly 5 elements
    std::cout &lt;&lt; sizeof(arr) &lt;&lt; std::endl;  // 20 (actual array size)
}

// Method 4: Template (best for generic code)
template&lt;size_t N&gt;
void func4(int (&amp;arr)[N]) {
    // Works for any size array
    std::cout &lt;&lt; "Array size: " &lt;&lt; N &lt;&lt; std::endl;
}

// Method 5: Modern C++ - use std::array or std::vector
void func5(const std::vector&lt;int&gt;&amp; vec) {
    // vec.size() always available!
    for (size_t i = 0; i &lt; vec.size(); i++) {
        std::cout &lt;&lt; vec[i] &lt;&lt; " ";
    }
}

int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    
    func1(arr, 5);           // OK
    func2(arr, 5);           // OK
    func3(arr);              // OK: size deduced from type
    func4(arr);              // OK: N = 5 automatically
    
    std::vector&lt;int&gt; vec = {10, 20, 30, 40, 50};
    func5(vec);              // Best: size is always known
    
    return 0;
}
</code></pre>
<h4 id="why-array-size-is-not-passed-automatically"><a class="header" href="#why-array-size-is-not-passed-automatically">Why Array Size is Not Passed Automatically:</a></h4>
<pre><code class="language-cpp">void mystery_function(int* arr) {
    // From the pointer alone, we cannot tell:
    // - Is this an array or single element?
    // - If array, how many elements?
    // - Where does it end?
    
    // This is dangerous:
    for (int i = 0; i &lt; 100; i++) {  // What if array has &lt; 100 elements?
        arr[i] = 0;  // Could write past array bounds!
    }
}

// Solution: Always pass size
void safe_function(int* arr, int size) {
    for (int i = 0; i &lt; size; i++) {
        arr[i] = 0;  // Safe: we know the bounds
    }
}
</code></pre>
<h3 id="multi-dimensional-arrays"><a class="header" href="#multi-dimensional-arrays">Multi-dimensional Arrays</a></h3>
<h4 id="static-multi-dimensional-arrays"><a class="header" href="#static-multi-dimensional-arrays">Static Multi-dimensional Arrays:</a></h4>
<pre><code class="language-cpp">int matrix[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};

// Memory layout is contiguous:
// [1][2][3][4][5][6][7][8][9][10][11][12]

std::cout &lt;&lt; matrix[1][2] &lt;&lt; std::endl;  // Output: 7
std::cout &lt;&lt; *(*(matrix + 1) + 2) &lt;&lt; std::endl;  // Also: 7
</code></pre>
<h4 id="dynamic-2d-arrays-method-1-array-of-pointers"><a class="header" href="#dynamic-2d-arrays-method-1-array-of-pointers">Dynamic 2D Arrays (Method 1: Array of Pointers):</a></h4>
<pre><code class="language-cpp">// Allocate array of pointers
int** matrix = new int*[3];  // 3 rows

// Allocate each row
for (int i = 0; i &lt; 3; i++) {
    matrix[i] = new int[4];  // 4 columns
}

// Use it
matrix[1][2] = 42;

// Deallocate (must free in reverse order)
for (int i = 0; i &lt; 3; i++) {
    delete[] matrix[i];  // Free each row
}
delete[] matrix;  // Free array of pointers
</code></pre>
<p><strong>Memory Layout:</strong></p>
<pre><code>Stack:        Heap:
┌────────┐    ┌─────┐    ┌────┬────┬────┬────┐
│ matrix │───&gt;│ ptr │───&gt;│ 1  │ 2  │ 3  │ 4  │  Row 0
└────────┘    ├─────┤    └────┴────┴────┴────┘
              │ ptr │───&gt;┌────┬────┬────┬────┐
              ├─────┤    │ 5  │ 6  │ 7  │ 8  │  Row 1
              │ ptr │─┐  └────┴────┴────┴────┘
              └─────┘ │  ┌────┬────┬────┬────┐
                      └─&gt;│ 9  │ 10 │ 11 │ 12 │  Row 2
                         └────┴────┴────┴────┘
Not contiguous in memory!
</code></pre>
<h4 id="dynamic-2d-arrays-method-2-contiguous-memory"><a class="header" href="#dynamic-2d-arrays-method-2-contiguous-memory">Dynamic 2D Arrays (Method 2: Contiguous Memory):</a></h4>
<pre><code class="language-cpp">// Allocate as single block (better for cache performance)
int* matrix = new int[3 * 4];  // Total elements

// Access using index calculation: matrix[row * cols + col]
int rows = 3, cols = 4;
matrix[1 * cols + 2] = 42;  // matrix[1][2] = 42

// Helper function for cleaner access
auto at = [&amp;](int r, int c) -&gt; int&amp; {
    return matrix[r * cols + c];
};

at(1, 2) = 42;

// Cleanup is simple
delete[] matrix;
</code></pre>
<p><strong>Memory Layout:</strong></p>
<pre><code>Contiguous block in heap:
┌────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐
│ 1  │ 2  │ 3  │ 4  │ 5  │ 6  │ 7  │ 8  │ 9  │ 10 │ 11 │ 12 │
└────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┘
 └─── Row 0 ───┘ └─── Row 1 ───┘ └─── Row 2 ───┘

Access: matrix[row * num_cols + col]
</code></pre>
<h3 id="summary-table-arrays-vs-pointers"><a class="header" href="#summary-table-arrays-vs-pointers">Summary Table: Arrays vs Pointers</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Static Array</th><th>Dynamic Array</th><th>Pointer</th></tr>
</thead>
<tbody>
<tr><td>Declaration</td><td><code>int arr[5]</code></td><td><code>int* arr = new int[5]</code></td><td><code>int* ptr</code></td></tr>
<tr><td>Size known at compile-time</td><td>✓ Yes</td><td>✗ No</td><td>✗ No</td></tr>
<tr><td>Can be reassigned</td><td>✗ No (constant pointer)</td><td>✓ Yes</td><td>✓ Yes</td></tr>
<tr><td>Stored on</td><td>Stack</td><td>Heap</td><td>Stack (pointer itself)</td></tr>
<tr><td>Automatic cleanup</td><td>✓ Yes</td><td>✗ No (need delete[])</td><td>✗ No</td></tr>
<tr><td>Sizeof gives</td><td>Array size</td><td>Pointer size</td><td>Pointer size</td></tr>
<tr><td>Passed to function</td><td>Decays to pointer</td><td>Already pointer</td><td>Pointer</td></tr>
</tbody>
</table>
</div>
<h3 id="best-practices-for-arrays"><a class="header" href="#best-practices-for-arrays">Best Practices for Arrays:</a></h3>
<pre><code class="language-cpp">// ❌ Avoid: C-style arrays for new code
int arr[100];

// ✅ Prefer: std::array (fixed size)
#include &lt;array&gt;
std::array&lt;int, 100&gt; arr;  // Size is part of type
arr.size();  // Always available

// ✅ Prefer: std::vector (dynamic size)
#include &lt;vector&gt;
std::vector&lt;int&gt; vec(100);  // Dynamic, resizable
vec.size();  // Always available
vec.push_back(42);  // Can grow

// ✅ For passing arrays to functions
void process(const std::vector&lt;int&gt;&amp; data) {
    // Size is always available via data.size()
}

// ✅ For 2D data
std::vector&lt;std::vector&lt;int&gt;&gt; matrix(rows, std::vector&lt;int&gt;(cols));
// Or for better performance:
std::vector&lt;int&gt; matrix(rows * cols);
</code></pre>
<p><a href="#table-of-contents">↑ Back to Table of Contents</a></p>
<hr>
<h2 id="7-const-pointers-variations"><a class="header" href="#7-const-pointers-variations">7. Const Pointers Variations</a></h2>
<p>There are three types of const pointer declarations, each with different meanings.</p>
<h3 id="1-pointer-to-constant-const-t-or-t-const"><a class="header" href="#1-pointer-to-constant-const-t-or-t-const">1. Pointer to Constant (<code>const T*</code> or <code>T const*</code>)</a></h3>
<pre><code class="language-cpp">int value = 42;
const int* ptr = &amp;value;  // Pointer to constant int

// *ptr = 100;  // ERROR: Cannot modify the value through ptr
value = 100;    // OK: Can modify value directly

int another = 50;
ptr = &amp;another; // OK: Can change where ptr points
</code></pre>
<p><strong>Memory View:</strong></p>
<pre><code>┌──────────────┐
│  value = 42  │ ← Can't modify via ptr
└──────────────┘
      ↑
      │ (can change this pointer)
   ┌──┴──┐
   │ ptr │
   └─────┘
</code></pre>
<h3 id="2-constant-pointer-t-const"><a class="header" href="#2-constant-pointer-t-const">2. Constant Pointer (<code>T* const</code>)</a></h3>
<pre><code class="language-cpp">int value = 42;
int* const ptr = &amp;value;  // Constant pointer to int

*ptr = 100;     // OK: Can modify the value
// ptr = &amp;another; // ERROR: Cannot change where ptr points
</code></pre>
<p><strong>Memory View:</strong></p>
<pre><code>┌──────────────┐
│ value = 100  │ ← Can modify via ptr
└──────────────┘
      ↑
      │ (FIXED - cannot change)
   ┌──┴──┐
   │ ptr │
   └─────┘
</code></pre>
<h3 id="3-constant-pointer-to-constant-const-t-const"><a class="header" href="#3-constant-pointer-to-constant-const-t-const">3. Constant Pointer to Constant (<code>const T* const</code>)</a></h3>
<pre><code class="language-cpp">int value = 42;
const int* const ptr = &amp;value;  // Constant pointer to constant int

// *ptr = 100;     // ERROR: Cannot modify the value
// ptr = &amp;another; // ERROR: Cannot change where ptr points
</code></pre>
<p><strong>Memory View:</strong></p>
<pre><code>┌──────────────┐
│  value = 42  │ ← Can't modify via ptr
└──────────────┘
      ↑
      │ (FIXED - cannot change)
   ┌──┴──┐
   │ ptr │
   └─────┘
</code></pre>
<h3 id="summary-table"><a class="header" href="#summary-table">Summary Table:</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Declaration</th><th>Can Modify Value?</th><th>Can Change Pointer?</th><th>Read as</th></tr>
</thead>
<tbody>
<tr><td><code>int* ptr</code></td><td>✓ Yes</td><td>✓ Yes</td><td>Pointer to int</td></tr>
<tr><td><code>const int* ptr</code></td><td>✗ No</td><td>✓ Yes</td><td>Pointer to const int</td></tr>
<tr><td><code>int* const ptr</code></td><td>✓ Yes</td><td>✗ No</td><td>Const pointer to int</td></tr>
<tr><td><code>const int* const ptr</code></td><td>✗ No</td><td>✗ No</td><td>Const pointer to const int</td></tr>
</tbody>
</table>
</div>
<h3 id="mnemonic-read-right-to-left"><a class="header" href="#mnemonic-read-right-to-left">Mnemonic: Read Right to Left</a></h3>
<pre><code class="language-cpp">const int* ptr;        // ptr is a pointer to const int
int* const ptr;        // ptr is a const pointer to int
const int* const ptr;  // ptr is a const pointer to const int
</code></pre>
<p><a href="#table-of-contents">↑ Back to Table of Contents</a></p>
<hr>
<h2 id="8-breaking-constantness-the-hack"><a class="header" href="#8-breaking-constantness-the-hack">8. Breaking Constantness (The Hack)</a></h2>
<p>While <code>const</code> is meant to protect data, C++ provides ways to remove const-ness. <strong>Use with extreme caution!</strong></p>
<h3 id="using-const_cast"><a class="header" href="#using-const_cast">Using <code>const_cast</code></a></h3>
<pre><code class="language-cpp">const int value = 42;
const int* const_ptr = &amp;value;

// Remove const using const_cast
int* mutable_ptr = const_cast&lt;int*&gt;(const_ptr);
*mutable_ptr = 100;  // Undefined Behavior if value was truly const!

std::cout &lt;&lt; value &lt;&lt; std::endl;  // May still print 42 due to optimization
std::cout &lt;&lt; *mutable_ptr &lt;&lt; std::endl;  // May print 100
</code></pre>
<h3 id="why-this-is-dangerous"><a class="header" href="#why-this-is-dangerous">Why This Is Dangerous:</a></h3>
<pre><code class="language-cpp">// Case 1: Originally non-const (OK)
int x = 42;
const int* ptr = &amp;x;
int* mutable_ptr = const_cast&lt;int*&gt;(ptr);
*mutable_ptr = 100;  // OK: x was not const originally

// Case 2: Originally const (UNDEFINED BEHAVIOR)
const int y = 42;
const int* ptr2 = &amp;y;
int* mutable_ptr2 = const_cast&lt;int*&gt;(ptr2);
*mutable_ptr2 = 100;  // UNDEFINED BEHAVIOR! Compiler may have optimized assuming y never changes
</code></pre>
<h3 id="compiler-optimizations-can-break-your-code"><a class="header" href="#compiler-optimizations-can-break-your-code">Compiler Optimizations Can Break Your Code:</a></h3>
<pre><code class="language-cpp">const int value = 42;

// Compiler might replace all uses of 'value' with literal 42
if (value == 42) {
    std::cout &lt;&lt; "Always true!" &lt;&lt; std::endl;
}

// Even if you modify via const_cast, the if statement
// might still use the literal 42 due to optimization!
</code></pre>
<h3 id="legitimate-use-case"><a class="header" href="#legitimate-use-case">Legitimate Use Case:</a></h3>
<pre><code class="language-cpp">// Working with legacy C APIs that don't use const correctly
void legacy_function(char* str);  // Doesn't modify str, but signature is wrong

void modern_code() {
    const char* message = "Hello";
    // We know legacy_function won't modify str
    legacy_function(const_cast&lt;char*&gt;(message));  // Acceptable if you're sure
}
</code></pre>
<h3 id="other-ways-to-break-const-all-bad"><a class="header" href="#other-ways-to-break-const-all-bad">Other Ways to Break Const (All bad):</a></h3>
<pre><code class="language-cpp">const int value = 42;

// Method 1: C-style cast (discouraged)
int* ptr1 = (int*)&amp;value;

// Method 2: reinterpret_cast (very dangerous)
int* ptr2 = reinterpret_cast&lt;int*&gt;(const_cast&lt;void*&gt;(static_cast&lt;const void*&gt;(&amp;value)));

// Method 3: memcpy (also undefined behavior)
int copy;
memcpy(&amp;copy, &amp;value, sizeof(int));
copy = 100;
memcpy(const_cast&lt;int*&gt;(&amp;value), &amp;copy, sizeof(int));
</code></pre>
<p><strong>Bottom Line:</strong> If you’re using <code>const_cast</code>, you’re probably doing something wrong. Reconsider your design.</p>
<p><a href="#table-of-contents">↑ Back to Table of Contents</a></p>
<hr>
<h2 id="9-placement-new-operator"><a class="header" href="#9-placement-new-operator">9. Placement New Operator</a></h2>
<p>Placement new constructs an object at a <strong>pre-allocated memory address</strong> without allocating new memory.</p>
<h3 id="basic-syntax"><a class="header" href="#basic-syntax">Basic Syntax:</a></h3>
<pre><code class="language-cpp">#include &lt;new&gt;  // Required for placement new

// Allocate raw memory buffer
char buffer[sizeof(int)];

// Construct an int at the buffer location
int* ptr = new (buffer) int(42);  // Placement new

std::cout &lt;&lt; *ptr &lt;&lt; std::endl;  // Output: 42

// Must manually call destructor (no delete needed for placement new)
ptr-&gt;~int();  // Destructor call (trivial for int, but important for classes)
</code></pre>
<h3 id="complex-example-with-classes"><a class="header" href="#complex-example-with-classes">Complex Example with Classes:</a></h3>
<pre><code class="language-cpp">class MyClass {
public:
    int x;
    double y;
    
    MyClass(int x_val, double y_val) : x(x_val), y(y_val) {
        std::cout &lt;&lt; "Constructor called" &lt;&lt; std::endl;
    }
    
    ~MyClass() {
        std::cout &lt;&lt; "Destructor called" &lt;&lt; std::endl;
    }
};

// Pre-allocate memory
alignas(MyClass) char buffer[sizeof(MyClass)];

// Construct object in buffer
MyClass* obj = new (buffer) MyClass(10, 3.14);

std::cout &lt;&lt; "x: " &lt;&lt; obj-&gt;x &lt;&lt; ", y: " &lt;&lt; obj-&gt;y &lt;&lt; std::endl;

// Must manually call destructor
obj-&gt;~MyClass();

// No delete needed - we didn't allocate memory with new
</code></pre>
<h3 id="memory-diagram"><a class="header" href="#memory-diagram">Memory Diagram:</a></h3>
<pre><code>Regular new:
┌────────────────────────────────────┐
│ new MyClass(10, 3.14)              │
├────────────────────────────────────┤
│ 1. Allocate memory (heap)          │
│ 2. Construct object in that memory │
│ 3. Return pointer                  │
└────────────────────────────────────┘

Placement new:
┌────────────────────────────────────┐
│ char buffer[sizeof(MyClass)];      │ ← Memory already exists
│ new (buffer) MyClass(10, 3.14);    │
├────────────────────────────────────┤
│ 1. Use provided address (buffer)   │
│ 2. Construct object there          │
│ 3. Return pointer                  │
└────────────────────────────────────┘
</code></pre>
<h3 id="use-cases"><a class="header" href="#use-cases">Use Cases:</a></h3>
<h4 id="1-memory-pools"><a class="header" href="#1-memory-pools">1. Memory Pools</a></h4>
<pre><code class="language-cpp">// Pre-allocate a pool of memory
const size_t POOL_SIZE = 1024;
char memory_pool[POOL_SIZE];
size_t offset = 0;

// Allocate objects from the pool
MyClass* obj1 = new (memory_pool + offset) MyClass(1, 1.1);
offset += sizeof(MyClass);

MyClass* obj2 = new (memory_pool + offset) MyClass(2, 2.2);
offset += sizeof(MyClass);

// Cleanup
obj1-&gt;~MyClass();
obj2-&gt;~MyClass();
</code></pre>
<h4 id="2-reconstructing-objects-in-place"><a class="header" href="#2-reconstructing-objects-in-place">2. Reconstructing Objects In-Place</a></h4>
<pre><code class="language-cpp">MyClass* obj = new MyClass(10, 3.14);

// Destroy and reconstruct with new values
obj-&gt;~MyClass();
new (obj) MyClass(20, 6.28);  // Reuse same memory

delete obj;  // Now delete is OK because original memory was from new
</code></pre>
<h4 id="3-custom-allocators-stdvector-etc"><a class="header" href="#3-custom-allocators-stdvector-etc">3. Custom Allocators (std::vector, etc.)</a></h4>
<pre><code class="language-cpp">template&lt;typename T&gt;
class CustomAllocator {
public:
    void construct(T* ptr, const T&amp; value) {
        new (ptr) T(value);  // Placement new
    }
    
    void destroy(T* ptr) {
        ptr-&gt;~T();  // Manual destructor call
    }
};
</code></pre>
<h3 id="important-rules"><a class="header" href="#important-rules">Important Rules:</a></h3>
<ol>
<li><strong>Never delete placement new memory</strong> unless the original memory was allocated with regular new</li>
<li><strong>Always call destructor manually</strong> for non-trivial types</li>
<li><strong>Ensure proper alignment</strong> using <code>alignas</code></li>
<li><strong>Be careful with memory lifetime</strong> - the buffer must outlive the object</li>
</ol>
<p><a href="#table-of-contents">↑ Back to Table of Contents</a></p>
<hr>
<h2 id="10-best-practices"><a class="header" href="#10-best-practices">10. Best Practices</a></h2>
<h3 id="1-always-initialize-pointers"><a class="header" href="#1-always-initialize-pointers">1. Always Initialize Pointers</a></h3>
<pre><code class="language-cpp">// Bad
int* ptr;  // Uninitialized - contains garbage

// Good
int* ptr = nullptr;  // Explicitly null
int* ptr2 = new int(42);  // Immediately initialized
</code></pre>
<h3 id="2-check-for-nullptr-before-dereferencing"><a class="header" href="#2-check-for-nullptr-before-dereferencing">2. Check for nullptr Before Dereferencing</a></h3>
<pre><code class="language-cpp">int* ptr = get_some_pointer();

if (ptr != nullptr) {
    *ptr = 100;  // Safe
}

// Or use modern syntax
if (ptr) {
    *ptr = 100;
}
</code></pre>
<h3 id="3-always-set-to-nullptr-after-delete"><a class="header" href="#3-always-set-to-nullptr-after-delete">3. Always Set to nullptr After delete</a></h3>
<pre><code class="language-cpp">int* ptr = new int(42);
delete ptr;
ptr = nullptr;  // Prevents dangling pointer

// Now safe to delete again (no-op)
delete ptr;  // OK: deleting nullptr is safe
</code></pre>
<h3 id="4-use-smart-pointers-modern-c--will-cover-in-detail-later"><a class="header" href="#4-use-smart-pointers-modern-c--will-cover-in-detail-later">4. Use Smart Pointers (Modern C++ : Will cover in detail later)</a></h3>
<pre><code class="language-cpp">#include &lt;memory&gt;

// Use unique_ptr for exclusive ownership
std::unique_ptr&lt;int&gt; ptr1 = std::make_unique&lt;int&gt;(42);

// Use shared_ptr for shared ownership
std::shared_ptr&lt;int&gt; ptr2 = std::make_shared&lt;int&gt;(100);

// No need to delete - automatic cleanup!
</code></pre>
<h3 id="5-match-newdelete-and-newdelete"><a class="header" href="#5-match-newdelete-and-newdelete">5. Match new/delete and new[]/delete[]</a></h3>
<pre><code class="language-cpp">// Single object
int* ptr = new int;
delete ptr;  // Correct

// Array
int* arr = new int[10];
delete[] arr;  // Correct - must use delete[]

// WRONG combinations:
// int* ptr = new int;
// delete[] ptr;  // WRONG!

// int* arr = new int[10];
// delete arr;  // WRONG!
</code></pre>
<h3 id="6-avoid-raw-pointers-for-ownership"><a class="header" href="#6-avoid-raw-pointers-for-ownership">6. Avoid Raw Pointers for Ownership</a></h3>
<pre><code class="language-cpp">// Bad: Who owns this? Who deletes it?
int* create_resource() {
    return new int(42);
}

// Good: Clear ownership
std::unique_ptr&lt;int&gt; create_resource() {
    return std::make_unique&lt;int&gt;(42);
}
</code></pre>
<h3 id="7-use-references-when-you-dont-need-nullptr"><a class="header" href="#7-use-references-when-you-dont-need-nullptr">7. Use References When You Don’t Need nullptr</a></h3>
<pre><code class="language-cpp">// If something must exist, use reference
void process(int&amp; value) {  // Cannot be null
    value = 42;
}

// Use pointer only if nullptr is meaningful
void process(int* value) {  // Can be null
    if (value) {
        *value = 42;
    }
}
</code></pre>
<h3 id="8-const-correctness"><a class="header" href="#8-const-correctness">8. Const Correctness</a></h3>
<pre><code class="language-cpp">// Promise not to modify through pointer
void read_only(const int* ptr) {
    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;
}

// Clear intent to modify
void modify(int* ptr) {
    *ptr = 100;
}
</code></pre>
<hr>
<h2 id="10-common-bugs"><a class="header" href="#10-common-bugs">10. Common Bugs</a></h2>
<h3 id="1-dangling-pointer"><a class="header" href="#1-dangling-pointer">1. Dangling Pointer</a></h3>
<pre><code class="language-cpp">int* create_dangling() {
    int x = 42;
    return &amp;x;  // BUG: x is destroyed when function returns
}

int* ptr = create_dangling();
*ptr = 100;  // Undefined behavior! Memory is invalid
</code></pre>
<p><strong>Fix:</strong></p>
<pre><code class="language-cpp">int* create_safe() {
    int* ptr = new int(42);
    return ptr;  // OK: Memory persists
}

// Or better: use smart pointer
std::unique_ptr&lt;int&gt; create_safer() {
    return std::make_unique&lt;int&gt;(42);
}
</code></pre>
<h3 id="2-double-delete"><a class="header" href="#2-double-delete">2. Double Delete</a></h3>
<pre><code class="language-cpp">int* ptr = new int(42);
delete ptr;
delete ptr;  // BUG: Double delete - undefined behavior!
</code></pre>
<p><strong>Fix:</strong></p>
<pre><code class="language-cpp">int* ptr = new int(42);
delete ptr;
ptr = nullptr;  // Set to null after delete
delete ptr;  // OK: Deleting nullptr is safe (no-op)
</code></pre>
<h3 id="3-memory-leak"><a class="header" href="#3-memory-leak">3. Memory Leak</a></h3>
<pre><code class="language-cpp">void leak_memory() {
    int* ptr = new int(42);
    // Forgot to delete!
}  // BUG: Memory is leaked

void leak_on_exception() {
    int* ptr = new int(42);
    some_function_that_throws();  // If this throws...
    delete ptr;  // ...this never executes - LEAK!
}
</code></pre>
<p><strong>Fix:</strong></p>
<pre><code class="language-cpp">void no_leak() {
    std::unique_ptr&lt;int&gt; ptr = std::make_unique&lt;int&gt;(42);
}  // Automatically cleaned up

void no_leak_on_exception() {
    std::unique_ptr&lt;int&gt; ptr = std::make_unique&lt;int&gt;(42);
    some_function_that_throws();  // Even if this throws, ptr is cleaned up
}
</code></pre>
<h3 id="4-array-delete-mismatch"><a class="header" href="#4-array-delete-mismatch">4. Array Delete Mismatch</a></h3>
<pre><code class="language-cpp">int* arr = new int[10];
delete arr;  // BUG: Should be delete[]

int* ptr = new int;
delete[] ptr;  // BUG: Should be delete
</code></pre>
<p><strong>Fix:</strong></p>
<pre><code class="language-cpp">int* arr = new int[10];
delete[] arr;  // Correct

// Or better: use std::vector
std::vector&lt;int&gt; arr(10);  // No manual delete needed
</code></pre>
<h3 id="5-using-after-delete"><a class="header" href="#5-using-after-delete">5. Using After Delete</a></h3>
<pre><code class="language-cpp">int* ptr = new int(42);
delete ptr;
*ptr = 100;  // BUG: Use after free - undefined behavior!
</code></pre>
<p><strong>Fix:</strong></p>
<pre><code class="language-cpp">int* ptr = new int(42);
delete ptr;
ptr = nullptr;  // Set to null

if (ptr) {
    *ptr = 100;  // Won't execute - safe
}
</code></pre>
<h3 id="6-lost-pointer"><a class="header" href="#6-lost-pointer">6. Lost Pointer</a></h3>
<pre><code class="language-cpp">int* ptr = new int(42);
ptr = new int(100);  // BUG: Lost reference to first allocation - LEAK!
</code></pre>
<p><strong>Fix:</strong></p>
<pre><code class="language-cpp">int* ptr = new int(42);
delete ptr;  // Clean up first
ptr = new int(100);

// Or use smart pointer
std::unique_ptr&lt;int&gt; ptr = std::make_unique&lt;int&gt;(42);
ptr = std::make_unique&lt;int&gt;(100);  // Old memory automatically deleted
</code></pre>
<h3 id="7-null-pointer-dereference"><a class="header" href="#7-null-pointer-dereference">7. Null Pointer Dereference</a></h3>
<pre><code class="language-cpp">int* ptr = nullptr;
*ptr = 42;  // BUG: Dereferencing null pointer - crash!
</code></pre>
<p><strong>Fix:</strong></p>
<pre><code class="language-cpp">int* ptr = nullptr;
if (ptr) {
    *ptr = 42;  // Safe
}

// Or use assert for debugging
#include &lt;cassert&gt;
assert(ptr != nullptr);
*ptr = 42;
</code></pre>
<h3 id="8-uninitialized-pointer"><a class="header" href="#8-uninitialized-pointer">8. Uninitialized Pointer</a></h3>
<pre><code class="language-cpp">int* ptr;  // Uninitialized - contains garbage
*ptr = 42;  // BUG: Writing to random memory!
</code></pre>
<p><strong>Fix:</strong></p>
<pre><code class="language-cpp">int* ptr = nullptr;  // Always initialize
if (ptr) {
    *ptr = 42;
}

// Or initialize immediately
int* ptr = new int;
*ptr = 42;
</code></pre>
<h3 id="9-pointer-arithmetic-out-of-bounds"><a class="header" href="#9-pointer-arithmetic-out-of-bounds">9. Pointer Arithmetic Out of Bounds</a></h3>
<pre><code class="language-cpp">int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr;
ptr += 10;  // BUG: Points outside array
*ptr = 100;  // Undefined behavior!
</code></pre>
<p><strong>Fix:</strong></p>
<pre><code class="language-cpp">int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr;

// Check bounds
if (ptr + 10 &lt; arr + 5) {
    ptr += 10;
    *ptr = 100;
}

// Or use std::vector with at()
std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
try {
    vec.at(10) = 100;  // Throws exception if out of bounds
} catch (const std::out_of_range&amp; e) {
    std::cerr &lt;&lt; "Out of bounds!" &lt;&lt; std::endl;
}
</code></pre>
<h3 id="10-mixing-mallocfree-with-newdelete"><a class="header" href="#10-mixing-mallocfree-with-newdelete">10. Mixing malloc/free with new/delete</a></h3>
<pre><code class="language-cpp">int* ptr = (int*)malloc(sizeof(int));
delete ptr;  // BUG: Must use free()

int* ptr2 = new int;
free(ptr2);  // BUG: Must use delete
</code></pre>
<p><strong>Fix:</strong></p>
<pre><code class="language-cpp">// C-style
int* ptr = (int*)malloc(sizeof(int));
free(ptr);

// C++-style (preferred)
int* ptr2 = new int;
delete ptr2;
</code></pre>
<p><a href="#table-of-contents">↑ Back to Table of Contents</a></p>
<hr>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<h3 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways:</a></h3>
<ol>
<li><strong>Pointers store memory addresses</strong>, not values</li>
<li><strong>Dereferencing accesses the value</strong> at the stored address</li>
<li><strong>Dynamic memory requires manual management</strong> (new/delete)</li>
<li><strong>All pointers are the same size</strong> regardless of type</li>
<li><strong>Const pointers have three variations</strong> with different restrictions</li>
<li><strong>Smart pointers are preferred</strong> in modern C++ for automatic memory management</li>
<li><strong>Always initialize pointers</strong> and check for nullptr</li>
<li><strong>Match allocation/deallocation methods</strong> (new/delete, new[]/delete[], malloc/free)</li>
</ol>
<h3 id="modern-c-recommendations"><a class="header" href="#modern-c-recommendations">Modern C++ Recommendations:</a></h3>
<ul>
<li>✅ Use <code>std::unique_ptr</code> and <code>std::shared_ptr</code></li>
<li>✅ Use <code>std::vector</code> instead of arrays</li>
<li>✅ Use references when ownership isn’t involved</li>
<li>✅ Use RAII (Resource Acquisition Is Initialization) principles(Will cover later)</li>
<li>❌ Avoid raw pointers for ownership</li>
<li>❌ Avoid manual memory management when possible</li>
<li>❌ Avoid <code>const_cast</code> unless absolutely necessary</li>
</ul>
<hr>
<p><strong>Remember: With great pointer power comes great responsibility. 🎯</strong></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="storage_classes.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="cpp_class_object_guide.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="storage_classes.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="cpp_class_object_guide.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
